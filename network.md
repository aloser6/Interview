1、键入网址到网页显示期间发生了什么？
- URL解析
- 通过默认网关到DNS服务器查询域名的IP地址（例如www.server.com.）
  - 先看浏览器有没有缓存，再看操作系统有没有缓存，再看本地host文件有没有。
  - 去问本地DNS服务器
  - 本地DNS服务器根据先去根DNS服务器（.），再去顶级DNS服务器（com），再去权威DNS服务器（瑟rver.com）。
IP包括ICMP(出错控制)和ARP协议(根据IP找MAC)
MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。
- 根据路由表判断哪张网卡作为源IP
交换机没有MAC
路由器又IP和MAC
MAC层协议有IP协议和ARP协议
在因特网传输过程中源IP和目的IP是不变的，MAC是不断改变的，改变为下一跳路由器的MAC
- 由交换机将包传输给路由器，路由器查路由表判断下一跳
如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发
如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。
- 确定下一条后路由器根据ARP协议确定下一跳的MAC地址
- 传到对应子网，后面就是解析过程了
2、TCP三次握手
- 第一次握手：客户端给服务端发送SYN(序号)，表明客户端有发送能力
- 第二次握手：服务端返回SYN和ACK(确认号)，表明服务端有发送和接受的能力
- 第三次握手：客户端发送ACK，表明客户端有接收能力
- 三次握手目的是保证双方都有发送和接收的能力。
3、Linux收发网络包
1. Linux 接收网络包的流程
- 网卡接受网络包-->DMA技术将网络包写入指定内存地址(RingBuffer环形缓冲区)-->中断唤醒数据接收程序(原本是中断告诉操作系统，但是收到一个网络包就打断cpu影响效率)-->用poll的方式轮询数据-->从RingBuffer中获取数据帧，用sk_buff(协议栈表示数据的数据结构)表示-->交给协议栈逐层处理
- 协议栈处理：
  - 网络接口层(检查报文合法性，找出上层协议，如是IPv4还是IPv6)
  - 网络层取出IP包，确认是否是发给本机，找出上层协议是TCP还是UDP
  - 传输层去除TCP/UDP头，根据「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区
  - 应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。
硬件中断处理函数会做如下的事情：
需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。
接着，发起「软中断」，然后恢复刚才屏蔽的中断。
2. Linux 发送网络包的流程
- 协议栈处理：
  - 应用层调用 Socket 系统调用发送数据包的接口，内核会申请一个sk_buff内存，将用户数据拷贝到sk_buff内存，将其加入发送缓冲区。
  - 传输层取出sk_buff，如果是TCP则拷贝一份sk_buff副本，当发送完成后释放sk_buff副本，当接收到ACK确认后释放sk_buff原始数据。
  - 网络层选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。
  - 网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。
sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。用相同的数据结构是为了防止每层拷贝一次
3. 发送网络数据的时候，涉及几次内存拷贝操作？
- 第一次：调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将数据从用户态拷贝到内核态
- 第二次：如果是TCP则会拷贝一份sk_buff副本
- 第三次：IP层发现数据大于MTU需要分片时则会申请额外的sk_buff
4、HTTP(超文本传输协议)常见面试题
- 粘包问题？？
- GET和POST有什么区别
  - GET是安全(指不破坏服务器资源)幂等的。POST是不安全不幂等的。
  - 如果是传输过程则两者都不安全，GET用URL，POST用body(可被抓包)。传输安全得HTTPS
- HTTP缓存问题??
- HTTP/1.1优缺点
  - 优点
    - 简单
    - 应用广泛
  - 缺点
    - 无状态使服务器不会去记录HTTP状态，使得每一次访问都得验证身份(Cookie解决)
    - 明文传输，消息可被直接阅读
    - 不安全。消息可能被篡改
- HTTP/1.0每次请求都会三次握手四次挥手，而HTTP/1.1提出长连接的通信方式(一次请求响应不会断开连接)
- 管道网络传输(第一次请求还没响应就发第二次请求)不怎么用(后面以无管道通信来)
- 队头阻塞(请求发出后，服务器那边因各种原因阻塞，导致响应迟迟不来)
5、HTTP 与 HTTPS
- 区别
  1. 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议
  2. 还需进行 SSL/TLS 的握手过程
  3. 端口号是 80，端口号是 443
  4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书
- HTTP面临的风险和HTTPS的解决方案
  - 风险:窃听风险(公钥加密，私钥解密)，篡改风险(私钥加密，公钥解密)，冒充风险(CA证书+数字签名)
  - 解决:信息加密，校验机制，身份证书
信息加密：混合加密
校验机制：摘要算法 + 数字签名
身份证书：数字证书
详见：https://xiaolincoding.com/network/2_http/http_interview.html#https-%E8%A7%A3%E5%86%B3%E4%BA%86-http-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98

6、HTTP/1.1优化(减少发送HTTP请求)
- 缓存技术
  - 客户端第一次访问服务端返回资源，并缓存到本地磁盘，下次访问如果资源没有过期直接从磁盘中获取
  - 如果资源过期了，则访问服务器，如果服务器发现资源没变则返回304，并重新设置本地缓存时间
- 减少HTTP请求次数
  - 将原本由客户端处理的重定向请求，交给代理服务器处理
  - 将多个小资源合并成一个大资源再传输
  - 按需访问资源，只访问当前用户看得到/用得到的资源
- 压缩响应资源
  - 通过无损(如霍夫曼编码)/有损压缩对资源压缩
7、有了HTTP为啥还要RPC
- 区别
  - HTTP一般采用Json，但是传输的内容一般有冗余(消息头的名称)。RPC一般采用体积更小的Protobuf，传输效率更高
  - 都是基于TCP的协议，知识定义了不同的消息格式
  - RPC只是个概念，像gRPC这种才是真正的协议，而HTTP本身就是协议
8、有了HTTP为啥还要WebSocket
- TCP
  - 特性：面向连接的，基于字节流，可靠的
  - TCP因为是字节流。没有边界。所以会有粘包问题，解决方法有两个，分别是 消息头和分隔符
  - TCP是全双工的，而HTTP是半双工的
- 区别
  - websocket和socket没有任何关系
  - websocket在同一时间内双方都可以主动的收发数据。而HTTP则是客户端请求服务端响应的方式
  - websocket主要用于交互频繁且需要全双工的服务场景
- websocket建立连接的过程
  - 首先是HTTP向服务端发送协议升级的请求，服务端将协议升级为websocket后返回给客户端，客户端也随之升级协议，也就是两次握手，之后便是websocket互相传输内容
9、HTTPS RSA握手(除去TCP握手，四次握手)
- TLS之RSA算法握手过程
[图片]
- 第一次握手：随机数，支持的密钥套件列表，版本等信息
- 第二次握手：随机数，密码套件，版本等信息  |  服务器证书(CA保证可信度，私钥加密保证是服务器发的)
- 第三次握手：从证书取出公钥，传公钥加密后的随机数，之后使用会话密钥通信(三个随机数生成)
- 第四次握手：确认信息
- 第三个随机数：客户端生成
- 证书链：根证书信任中间证书，中间证书信任服务器证书，浏览器信任服务器证书
RSA算法缺陷：私钥不能泄露，使用会话密钥前传输的一些信息是明文传输的，一旦密钥泄露，之前截取的报文就能被解密
10、HTTPS ECDHE握手(除去TCP握手，四次握手)
- 第一次握手：随机数，支持的密钥套件列表，版本等信息
- 第二次握手：随机数，密码套件，版本等信息  |  服务器证书(CA保证可信度，私钥加密保证是服务器发的)
- 第三次握手：会话密钥 是 客户端随机数 + 服务端随机数 + （ECDHE 算法算出的共享密钥）生成的
- 第四次握手：确认信息
- 第三个随机数：使用椭圆曲线来算出ECDHE共享密码
使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间
11、HTTP/2  牛逼在哪？
- 兼容 HTTP/1.1
- 头部压缩
  - v1.1：
    - http/1.1 的 Content-Encoding 字段指定 Body 的压缩方式，例如 gzip 。而 Head 则没有进行压缩
    - 存在的问题
含很多固定的字段，有必要压缩
大量的请求和响应的报文里有很多字段值都是重复的
字段是 ASCII 编码的，虽然易于人类观察，但效率低
  - v2：
    - 使用 HPACK 对头部进行压缩，其中HPACK主要组成部分：
      - 静态字典(存储的是高频出现的)
        - 静态表是写入HTTP/2框架里的，不会发生变化，总共61组(用二进制数表示如method:GET这样的字段，省下大量传输数据)
      - 动态字典
        - 如果静态表中没有相应字段子以62为起点创建该字段的索引
      - Huffman 编码（压缩算法）
        - 用Huffman算法进行进一步的压缩
- 二进制帧
