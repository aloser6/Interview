## 1、键入网址到网页显示期间发生了什么？
- URL解析
- 通过默认网关到DNS服务器查询域名的IP地址（例如www.server.com）
  - 先看浏览器有没有缓存，再看操作系统有没有缓存，再看本地host文件有没有。
  - 去问本地DNS服务器
  - 本地DNS服务器根据先去根DNS服务器（.），再去顶级DNS服务器（com），再去权威DNS服务器（server.com）。

 ```markdown
IP包括ICMP(出错控制)和ARP协议(根据IP找MAC)
MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。
```
- 根据路由表判断哪张网卡作为源IP
```markdown
交换机没有MAC
路由器又IP和MAC
MAC层协议有IP协议和ARP协议
在因特网传输过程中源IP和目的IP是不变的，MAC是不断改变的，改变为下一跳路由器的MAC
```
- 由交换机将包传输给路由器，路由器查路由表判断下一跳
```markdown
如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发
如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。
```
- 确定下一条后路由器根据ARP协议确定下一跳的MAC地址
- 传到对应子网，后面就是解析过程了

## 2、TCP三次握手
- 第一次握手：客户端给服务端发送SYN(序号)，表明客户端有发送能力
- 第二次握手：服务端返回SYN和ACK(确认号)，表明服务端有发送和接受的能力
- 第三次握手：客户端发送ACK，表明客户端有接收能力
- 三次握手目的是保证双方都有发送和接收的能力。

## 3、Linux收发网络包
#### 1. Linux 接收网络包的流程
- 网卡接受网络包-->DMA技术将网络包写入指定内存地址(RingBuffer环形缓冲区)-->中断唤醒数据接收程序(原本是中断告诉操作系统，但是收到一个网络包就打断cpu影响效率)-->用poll的方式轮询数据-->从RingBuffer中获取数据帧，用sk_buff(协议栈表示数据的数据结构)表示-->交给协议栈逐层处理
- 协议栈处理：
  - 网络接口层(检查报文合法性，找出上层协议，如是IPv4还是IPv6)
  - 网络层取出IP包，确认是否是发给本机，找出上层协议是TCP还是UDP
  - 传输层去除TCP/UDP头，根据「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区
  - 应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。
```markdown
硬件中断处理函数会做如下的事情：
需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。
接着，发起「软中断」，然后恢复刚才屏蔽的中断。
```

#### 2. Linux 发送网络包的流程
- 协议栈处理：
  - 应用层调用 Socket 系统调用发送数据包的接口，内核会申请一个sk_buff内存，将用户数据拷贝到sk_buff内存，将其加入发送缓冲区。
  - 传输层取出sk_buff，如果是TCP则拷贝一份sk_buff副本，当发送完成后释放sk_buff副本，当接收到ACK确认后释放sk_buff原始数据。
  - 网络层选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。
  - 网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。
  ```markdown
sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。用相同的数据结构是为了防止每层拷贝一次
```

#### 3. 发送网络数据的时候，涉及几次内存拷贝操作？
- 第一次：调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将数据从用户态拷贝到内核态
- 第二次：如果是TCP则会拷贝一份sk_buff副本
- 第三次：IP层发现数据大于MTU需要分片时则会申请额外的sk_buff

## 4、HTTP(超文本传输协议)常见面试题
- 粘包问题？？
- GET和POST有什么区别
  - GET是安全(指不破坏服务器资源)幂等的。POST是不安全不幂等的。
  - 如果是传输过程则两者都不安全，GET用URL，POST用body(可被抓包)。传输安全得HTTPS
- HTTP缓存问题??
- HTTP/1.1优缺点
  - 优点
    - 简单
    - 应用广泛
  - 缺点
    - 无状态使服务器不会去记录HTTP状态，使得每一次访问都得验证身份(Cookie解决)
    - 明文传输，消息可被直接阅读
    - 不安全。消息可能被篡改
- HTTP/1.0每次请求都会三次握手四次挥手，而HTTP/1.1提出长连接的通信方式(一次请求响应不会断开连接)
- 管道网络传输(第一次请求还没响应就发第二次请求)不怎么用(后面以无管道通信来)
- 队头阻塞(请求发出后，服务器那边因各种原因阻塞，导致响应迟迟不来)

## 5、HTTP 与 HTTPS
- 区别
  1. 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议
  2. 还需进行 SSL/TLS 的握手过程
  3. 端口号是 80，端口号是 443
  4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书
- HTTP面临的风险和HTTPS的解决方案
  - 风险:窃听风险(公钥加密，私钥解密)，篡改风险(私钥加密，公钥解密)，冒充风险(CA证书+数字签名)
  - 解决:信息加密，校验机制，身份证书
```markdown
信息加密：混合加密
校验机制：摘要算法 + 数字签名
身份证书：数字证书
```
- 详见[Link](https://xiaolincoding.com/network/2_http/http_interview.html#https-%E8%A7%A3%E5%86%B3%E4%BA%86-http-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98)

## 6、HTTP/1.1优化(减少发送HTTP请求)
- 缓存技术
  - 客户端第一次访问服务端返回资源，并缓存到本地磁盘，下次访问如果资源没有过期直接从磁盘中获取
  - 如果资源过期了，则访问服务器，如果服务器发现资源没变则返回304，并重新设置本地缓存时间
- 减少HTTP请求次数
  - 将原本由客户端处理的重定向请求，交给代理服务器处理
  - 将多个小资源合并成一个大资源再传输
  - 按需访问资源，只访问当前用户看得到/用得到的资源
- 压缩响应资源
  - 通过无损(如霍夫曼编码)/有损压缩对资源压缩

## 7、有了HTTP为啥还要RPC
- 区别
  - HTTP一般采用Json，但是传输的内容一般有冗余(消息头的名称)。RPC一般采用体积更小的Protobuf，传输效率更高
  - 都是基于TCP的协议，知识定义了不同的消息格式
  - RPC只是个概念，像gRPC这种才是真正的协议，而HTTP本身就是协议

## 8、有了HTTP为啥还要WebSocket
- TCP
  - 特性：面向连接的，基于字节流，可靠的
  - TCP因为是字节流。没有边界。所以会有粘包问题，解决方法有两个，分别是 消息头和分隔符
  - TCP是全双工的，而HTTP是半双工的
- 区别
  - websocket和socket没有任何关系
  - websocket在同一时间内双方都可以主动的收发数据。而HTTP则是客户端请求服务端响应的方式
  - websocket主要用于交互频繁且需要全双工的服务场景
- websocket建立连接的过程
  - 首先是HTTP向服务端发送协议升级的请求，服务端将协议升级为websocket后返回给客户端，客户端也随之升级协议，也就是两次握手，之后便是websocket互相传输内容

## 9、HTTPS RSA握手(除去TCP握手，四次握手)
- TLS之RSA算法握手过程
![图片](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png)
- 第一次握手：随机数，支持的密钥套件列表，版本等信息
- 第二次握手：随机数，密码套件，版本等信息  |  服务器证书(CA保证可信度，私钥加密保证是服务器发的)
- 第三次握手：从证书取出公钥，传公钥加密后的随机数，之后使用会话密钥通信(三个随机数生成)
- 第四次握手：确认信息
- 第三个随机数：客户端生成
- 证书链：根证书信任中间证书，中间证书信任服务器证书，浏览器信任服务器证书
RSA算法缺陷：私钥不能泄露，使用会话密钥前传输的一些信息是明文传输的，一旦密钥泄露，之前截取的报文就能被解密

## 10、HTTPS ECDHE握手(除去TCP握手，四次握手)
- 第一次握手：随机数，支持的密钥套件列表，版本等信息
- 第二次握手：随机数，密码套件，版本等信息  |  服务器证书(CA保证可信度，私钥加密保证是服务器发的)
- 第三次握手：会话密钥 是 客户端随机数 + 服务端随机数 + （ECDHE 算法算出的共享密钥）生成的
- 第四次握手：确认信息
- 第三个随机数：使用椭圆曲线来算出ECDHE共享密码
使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间

## 11、HTTP/2  牛逼在哪？
- 兼容 HTTP/1.1
- 头部压缩
  - v1.1：
    - http/1.1 的 Content-Encoding 字段指定 Body 的压缩方式，例如 gzip 。而 Head 则没有进行压缩
    - 存在的问题
```markdown
含很多固定的字段，有必要压缩
大量的请求和响应的报文里有很多字段值都是重复的
字段是 ASCII 编码的，虽然易于人类观察，但效率低
```
  - v2：
    - 使用 HPACK 对头部进行压缩，其中HPACK主要组成部分：
      - 静态字典(存储的是高频出现的)
        - 静态表是写入HTTP/2框架里的，不会发生变化，总共61组(用二进制数表示如method:GET这样的字段，省下大量传输数据)
      - 动态字典
        - 如果静态表中没有相应字段子以62为起点创建该字段的索引
      - Huffman 编码（压缩算法）
        - 用Huffman算法进行进一步的压缩
- 二进制帧
  - 指将原本HTTP/1.1传输的文本格式转换成HTTP/2传输的二进制格式，例如原本传输POST得传输四个字符P O S T，现在只需要传输静态表中的索引，即二进制数
-  并发传输
  - HTTP/1.1每发送一个请求都得等上一个请求处理完才能处理这个请求，如果上一个请求处理时间太长就会造成队头阻塞，HTTP/2采用并发解决这个问题。
  - HTTP/2的并发策略为：
    - 1 个 TCP 连接包含一个或者多个 Stream
    - Stream 里可以包含 1 个或多个 Message。Message 对应 HTTP/1 中的请求或响应
    - Message 里包含一条或者多个 Frame，Frame 以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）
  - 原本如果要实现100个并发得创建100TCP连接，现在100个并发只需要1个连接
- ![图片](https://cdn.xiaolincoding.com//picgo/image-20240105143224839.png)
- HTTP/2通过这项技术也实现了主动推送的技术。而HTTP/1.1是半双工，只有客户端主动请求服务端才会响应，不支持推送

---
12、TCP 三次握手与四次挥手面试题
- 控制位：ACK，RST(异常强制断开)，SYN，FIN(之后不会有数据，希望断开)
- 什么是TCP
  - 面向连接：一对一
  - 可靠的：保证报文可以到达接收端
  - 字节流：报文可能会被操作系统分组成多个TCP报文
- 什么是TCP连接
  - Socket：由 IP 地址和端口号组成
  - 序列号：用来解决乱序问题等
  - 窗口大小：用来做流量控制
- 如何唯一确定一个TCP连接(TCP四元组)
  - 源地址，源端口
  - 目的地址，目的端口
- TCP和UDP的区别
  - TCP面向连接。UDP面向无连接(不需要连接也可以传输数据)
  - TCP一对一。UDP一对多
  - TCP保证可靠交付，无差错，不丢失，不重复，按序到达。UDP是尽可能交付
  - TCP有拥塞控制和流量控制
  - 首部开销不一样
  - TCP流式传输，UDP报文传输
  - TCP基于MSS分片，UDP基于MTU分片
- TCP和UDP应用场景
  - TCP
    - FTP 文件传输
    - HTTP/HTTPS
  - UDP
    - 音频，视频，广播
- TCP和UDP能用一个端口吗
  - 可以，因为接受的包可以根据包头区分式TCP还是UDP进而确定是哪个进程的消息
- TCP建立连接
[图片]
- 第三次握手是可以携带数据的，前两次不行
- linux查看TCP连接状态 netstat -napt
13、为什么是三次握手？不是两次、四次？
- 网上普遍但片面的说法：因为三次握手才能保证双方具有收发能力
- 历史连接指下图中被网络阻塞的Seq Num=90。RST负责中断连接
- 三次握手的原因：
  - 为了防止旧的重复连接初始化造成混乱(RFC主要原因)
  - 同步双方初始序列号
  - 避免资源浪费，两次握手很显然不能解决 历史连接 问题。四次个人认为没必要是浪费资源的行为
[图片]
14、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？
- 主要原因有两个方面：
  - 为了防止历史报文被下一个相同四元组的连接接收（主要方面）
  - 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收
[图片]
15、初始序列号 ISN 是如何随机产生的？
- 产生过程
  - ISN = M + F(localhost, localport, remotehost, remoteport)，M是计时器，每思维秒+1，然后再根据Hash算法算出ISN
- 起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。
16、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
- 原因
  - 只按IP层的MTU来分片的话，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。
  - TCP也按MSS来分片重传的分片大小会小很多
- 建立连接的时候通常要协商双方的 MSS 值
17、第一次握手丢失了，会发生什么？
- 发生的事
  - 首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。
  - 客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，且每次超时的时间是上一次的 2 倍。
  - 达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接
18、第二次握手丢失了，会发生什么？
- 发生的事
  - 如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。
  - 如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。
19、第三次握手丢失了，会发生什么？
- 发生的事
  - 如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。
  - ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文，即客户端不会主动传ACK报文
20、什么是 SYN 攻击？
- 假设攻击者短时间伪造不同 IP 地址的 SYN 报文，久而久之就会占满服务端的半连接队列
- 当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。
[图片]
在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
半连接队列，也称 SYN 队列；
全连接队列，也称 accept 队列；
21、如何避免 SYN 攻击？
- 方法：
  - 调大 netdev_max_backlog；
    - 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包
  - 增大 TCP 半连接队列；
  - 开启 tcp_syncookies；
    - 开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接
  - 减少 SYN+ACK 重传次数
    - 内核参数决定（默认值是 5 次），比如将 tcp_synack_retries 减少到 2 次：
22、TCP 四次挥手过程是怎样的？
[图片]
23、为什么挥手需要四次？
- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
24、第一次挥手丢失了，会发生什么？
- 如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文
- 调用 close 函数后，就会向服务端发送 FIN 报文
26、第二次挥手丢失了，会发生什么？
- ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。
- 默认值是 60 秒
27、第三次挥手丢失了，会发生什么？
- 如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文
- 内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。
28、第四次挥手丢失了，会发生什么？
- 如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文
- TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。
29、为什么 TIME_WAIT 等待的时间是 2MSL？
- MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
- TIME_WAIT 等待 2 倍的 MSL，所以一来一回需要等待 2 倍的时间。
30、为什么需要 TIME_WAIT 状态？
