## 1、键入网址到网页显示期间发生了什么？
- URL解析
- 通过默认网关到DNS服务器查询域名的IP地址（例如www.server.com）
  - 先看浏览器有没有缓存，再看操作系统有没有缓存，再看本地host文件有没有。
  - 去问本地DNS服务器
  - 本地DNS服务器根据先去根DNS服务器（.），再去顶级DNS服务器（com），再去权威DNS服务器（server.com）。

 ```markdown
IP包括ICMP(出错控制)和ARP协议(根据IP找MAC)
MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。
```
- 根据路由表判断哪张网卡作为源IP
```markdown
交换机没有MAC
路由器又IP和MAC
MAC层协议有IP协议和ARP协议
在因特网传输过程中源IP和目的IP是不变的，MAC是不断改变的，改变为下一跳路由器的MAC
```
- 由交换机将包传输给路由器，路由器查路由表判断下一跳
```markdown
如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发
如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。
```
- 确定下一条后路由器根据ARP协议确定下一跳的MAC地址
- 传到对应子网，后面就是解析过程了

## 2、TCP三次握手
- 第一次握手：客户端给服务端发送SYN(序号)，表明客户端有发送能力
- 第二次握手：服务端返回SYN和ACK(确认号)，表明服务端有发送和接受的能力
- 第三次握手：客户端发送ACK，表明客户端有接收能力
- 三次握手目的是保证双方都有发送和接收的能力。

## 3、Linux收发网络包
#### 1. Linux 接收网络包的流程
- 网卡接受网络包-->DMA技术将网络包写入指定内存地址(RingBuffer环形缓冲区)-->中断唤醒数据接收程序(原本是中断告诉操作系统，但是收到一个网络包就打断cpu影响效率)-->用poll的方式轮询数据-->从RingBuffer中获取数据帧，用sk_buff(协议栈表示数据的数据结构)表示-->交给协议栈逐层处理
- 协议栈处理：
  - 网络接口层(检查报文合法性，找出上层协议，如是IPv4还是IPv6)
  - 网络层取出IP包，确认是否是发给本机，找出上层协议是TCP还是UDP
  - 传输层去除TCP/UDP头，根据「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区
  - 应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。
```markdown
硬件中断处理函数会做如下的事情：
需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。
接着，发起「软中断」，然后恢复刚才屏蔽的中断。
```

#### 2. Linux 发送网络包的流程
- 协议栈处理：
  - 应用层调用 Socket 系统调用发送数据包的接口，内核会申请一个sk_buff内存，将用户数据拷贝到sk_buff内存，将其加入发送缓冲区。
  - 传输层取出sk_buff，如果是TCP则拷贝一份sk_buff副本，当发送完成后释放sk_buff副本，当接收到ACK确认后释放sk_buff原始数据。
  - 网络层选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。
  - 网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。
```markdown
sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。用相同的数据结构是为了防止每层拷贝一次
```

#### 3. 发送网络数据的时候，涉及几次内存拷贝操作？
- 第一次：调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将数据从用户态拷贝到内核态
- 第二次：如果是TCP则会拷贝一份sk_buff副本
- 第三次：IP层发现数据大于MTU需要分片时则会申请额外的sk_buff

## 4、HTTP(超文本传输协议)常见面试题
- 粘包问题？？
- GET和POST有什么区别
  - GET是安全(指不破坏服务器资源)幂等的。POST是不安全不幂等的。
  - 如果是传输过程则两者都不安全，GET用URL，POST用body(可被抓包)。传输安全得HTTPS
- HTTP缓存问题??
- HTTP/1.1优缺点
  - 优点
    - 简单
    - 应用广泛
  - 缺点
    - 无状态使服务器不会去记录HTTP状态，使得每一次访问都得验证身份(Cookie解决)
    - 明文传输，消息可被直接阅读
    - 不安全。消息可能被篡改
- HTTP/1.0每次请求都会三次握手四次挥手，而HTTP/1.1提出长连接的通信方式(一次请求响应不会断开连接)
- 管道网络传输(第一次请求还没响应就发第二次请求)不怎么用(后面以无管道通信来)
- 队头阻塞(请求发出后，服务器那边因各种原因阻塞，导致响应迟迟不来)

## 5、HTTP 与 HTTPS
- 区别
  1. 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议
  2. 还需进行 SSL/TLS 的握手过程
  3. 端口号是 80，端口号是 443
  4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书
- HTTP面临的风险和HTTPS的解决方案
  - 风险:窃听风险(公钥加密，私钥解密)，篡改风险(私钥加密，公钥解密)，冒充风险(CA证书+数字签名)
  - 解决:信息加密，校验机制，身份证书
```markdown
信息加密：混合加密
校验机制：摘要算法 + 数字签名
身份证书：数字证书
```
- 详见[Link](https://xiaolincoding.com/network/2_http/http_interview.html#https-%E8%A7%A3%E5%86%B3%E4%BA%86-http-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98)

## 6、HTTP/1.1优化(减少发送HTTP请求)
- 缓存技术
  - 客户端第一次访问服务端返回资源，并缓存到本地磁盘，下次访问如果资源没有过期直接从磁盘中获取
  - 如果资源过期了，则访问服务器，如果服务器发现资源没变则返回304，并重新设置本地缓存时间
- 减少HTTP请求次数
  - 将原本由客户端处理的重定向请求，交给代理服务器处理
  - 将多个小资源合并成一个大资源再传输
  - 按需访问资源，只访问当前用户看得到/用得到的资源
- 压缩响应资源
  - 通过无损(如霍夫曼编码)/有损压缩对资源压缩

## 7、有了HTTP为啥还要RPC
- 区别
  - HTTP一般采用Json，但是传输的内容一般有冗余(消息头的名称)。RPC一般采用体积更小的Protobuf，传输效率更高
  - 都是基于TCP的协议，知识定义了不同的消息格式
  - RPC只是个概念，像gRPC这种才是真正的协议，而HTTP本身就是协议

## 8、有了HTTP为啥还要WebSocket
- TCP
  - 特性：面向连接的，基于字节流，可靠的
  - TCP因为是字节流。没有边界。所以会有粘包问题，解决方法有两个，分别是 消息头和分隔符
  - TCP是全双工的，而HTTP是半双工的
- 区别
  - websocket和socket没有任何关系
  - websocket在同一时间内双方都可以主动的收发数据。而HTTP则是客户端请求服务端响应的方式
  - websocket主要用于交互频繁且需要全双工的服务场景
- websocket建立连接的过程
  - 首先是HTTP向服务端发送协议升级的请求，服务端将协议升级为websocket后返回给客户端，客户端也随之升级协议，也就是两次握手，之后便是websocket互相传输内容

## 9、HTTPS RSA握手(除去TCP握手，四次握手)
- TLS之RSA算法握手过程
![图片](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png)
- 第一次握手：随机数，支持的密钥套件列表，版本等信息
- 第二次握手：随机数，密码套件，版本等信息  |  服务器证书(CA保证可信度，私钥加密保证是服务器发的)
- 第三次握手：从证书取出公钥，传公钥加密后的随机数，之后使用会话密钥通信(三个随机数生成)
- 第四次握手：确认信息
- 第三个随机数：客户端生成
- 证书链：根证书信任中间证书，中间证书信任服务器证书，浏览器信任服务器证书
RSA算法缺陷：私钥不能泄露，使用会话密钥前传输的一些信息是明文传输的，一旦密钥泄露，之前截取的报文就能被解密

## 10、HTTPS ECDHE握手(除去TCP握手，四次握手)
- 第一次握手：随机数，支持的密钥套件列表，版本等信息
- 第二次握手：随机数，密码套件，版本等信息  |  服务器证书(CA保证可信度，私钥加密保证是服务器发的)
- 第三次握手：会话密钥 是 客户端随机数 + 服务端随机数 + （ECDHE 算法算出的共享密钥）生成的
- 第四次握手：确认信息
- 第三个随机数：使用椭圆曲线来算出ECDHE共享密码
使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间

## 11、HTTP/2  牛逼在哪？
- 兼容 HTTP/1.1
- 头部压缩
  - v1.1：
    - http/1.1 的 Content-Encoding 字段指定 Body 的压缩方式，例如 gzip 。而 Head 则没有进行压缩
    - 存在的问题
```markdown
含很多固定的字段，有必要压缩
大量的请求和响应的报文里有很多字段值都是重复的
字段是 ASCII 编码的，虽然易于人类观察，但效率低
```
  - v2：
    - 使用 HPACK 对头部进行压缩，其中HPACK主要组成部分：
      - 静态字典(存储的是高频出现的)
        - 静态表是写入HTTP/2框架里的，不会发生变化，总共61组(用二进制数表示如method:GET这样的字段，省下大量传输数据)
      - 动态字典
        - 如果静态表中没有相应字段子以62为起点创建该字段的索引
      - Huffman 编码（压缩算法）
        - 用Huffman算法进行进一步的压缩
- 二进制帧
  - 指将原本HTTP/1.1传输的文本格式转换成HTTP/2传输的二进制格式，例如原本传输POST得传输四个字符P O S T，现在只需要传输静态表中的索引，即二进制数
-  并发传输
  - HTTP/1.1每发送一个请求都得等上一个请求处理完才能处理这个请求，如果上一个请求处理时间太长就会造成队头阻塞，HTTP/2采用并发解决这个问题。
  - HTTP/2的并发策略为：
    - 1 个 TCP 连接包含一个或者多个 Stream
    - Stream 里可以包含 1 个或多个 Message。Message 对应 HTTP/1 中的请求或响应
    - Message 里包含一条或者多个 Frame，Frame 以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）
  - 原本如果要实现100个并发得创建100TCP连接，现在100个并发只需要1个连接
- ![图片](https://cdn.xiaolincoding.com//picgo/image-20240105143224839.png)
- HTTP/2通过这项技术也实现了主动推送的技术。而HTTP/1.1是半双工，只有客户端主动请求服务端才会响应，不支持推送

---
## 12、TCP 三次握手与四次挥手面试题
- 控制位：ACK，RST(异常强制断开)，SYN，FIN(之后不会有数据，希望断开)
- 什么是TCP
  - 面向连接：一对一
  - 可靠的：保证报文可以到达接收端
  - 字节流：报文可能会被操作系统分组成多个TCP报文
- 什么是TCP连接
  - Socket：由 IP 地址和端口号组成
  - 序列号：用来解决乱序问题等
  - 窗口大小：用来做流量控制
- 如何唯一确定一个TCP连接(TCP四元组)
  - 源地址，源端口
  - 目的地址，目的端口
- TCP和UDP的区别
  - TCP面向连接。UDP面向无连接(不需要连接也可以传输数据)
  - TCP一对一。UDP一对多
  - TCP保证可靠交付，无差错，不丢失，不重复，按序到达。UDP是尽可能交付
  - TCP有拥塞控制和流量控制
  - 首部开销不一样
  - TCP流式传输，UDP报文传输
  - TCP基于MSS分片，UDP基于MTU分片
- TCP和UDP应用场景
  - TCP
    - FTP 文件传输
    - HTTP/HTTPS
  - UDP
    - 音频，视频，广播
- TCP和UDP能用一个端口吗
  - 可以，因为接受的包可以根据包头区分式TCP还是UDP进而确定是哪个进程的消息
- TCP建立连接
![图片](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)
- 第三次握手是可以携带数据的，前两次不行
- linux查看TCP连接状态 netstat -napt

## 13、为什么是三次握手？不是两次、四次？
- 网上普遍但片面的说法：因为三次握手才能保证双方具有收发能力
- 历史连接指下图中被网络阻塞的Seq Num=90。RST负责中断连接
- 三次握手的原因：
  - 为了防止旧的重复连接初始化造成混乱(RFC主要原因)
  - 同步双方初始序列号
  - 避免资源浪费，两次握手很显然不能解决 历史连接 问题。四次个人认为没必要是浪费资源的行为
![图片](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png)

## 14、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？
- 主要原因有两个方面：
  - 为了防止历史报文被下一个相同四元组的连接接收（主要方面）
  - 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收
![图片](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E7%9B%B8%E5%90%8C.png)

## 15、初始序列号 ISN 是如何随机产生的？
- 产生过程
  - ISN = M + F(localhost, localport, remotehost, remoteport)，M是计时器，每思维秒+1，然后再根据Hash算法算出ISN
- 起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。

## 16、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
- 原因
  - 只按IP层的MTU来分片的话，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。
  - TCP也按MSS来分片重传的分片大小会小很多
- 建立连接的时候通常要协商双方的 MSS 值

## 17、第一次握手丢失了，会发生什么？
- 发生的事
  - 首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。
  - 客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，且每次超时的时间是上一次的 2 倍。
  - 达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接

## 18、第二次握手丢失了，会发生什么？
- 发生的事
  - 如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。
  - 如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。

## 19、第三次握手丢失了，会发生什么？
- 发生的事
  - 如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。
  - ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文，即客户端不会主动传ACK报文

## 20、什么是 SYN 攻击？
- 假设攻击者短时间伪造不同 IP 地址的 SYN 报文，久而久之就会占满服务端的半连接队列
- 当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。
![图片](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png)
在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
半连接队列，也称 SYN 队列；
全连接队列，也称 accept 队列；

## 21、如何避免 SYN 攻击？
- 方法：
  - 调大 netdev_max_backlog；
    - 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包
  - 增大 TCP 半连接队列；
  - 开启 tcp_syncookies；
    - 开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接
  - 减少 SYN+ACK 重传次数
    - 内核参数决定（默认值是 5 次），比如将 tcp_synack_retries 减少到 2 次：

## 22、TCP 四次挥手过程是怎样的？
![图片](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

## 23、为什么挥手需要四次？
- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

## 24、第一次挥手丢失了，会发生什么？
- 如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文
- 调用 close 函数后，就会向服务端发送 FIN 报文

## 25、第二次挥手丢失了，会发生什么？
- ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。
- 默认值是 60 秒

## 26、第三次挥手丢失了，会发生什么？
- 如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文
- 内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。

## 27、第四次挥手丢失了，会发生什么？
- 如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文
- TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。

## 28、为什么 TIME_WAIT 等待的时间是 2MSL？
- MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
- TIME_WAIT 等待 2 倍的 MSL，所以一来一回需要等待 2 倍的时间。

## 29、为什么需要 TIME_WAIT 状态？
- 防止历史连接中的数据，被后面相同四元组的连接错误的接收
- 保证「被动关闭连接」的一方，能被正确的关闭

## 30、TIME_WAIT 过多有什么危害？
- 第一是占用系统资源，如文件描述符、内存资源、CPU 资源、线程资源等
- 第二是占用端口资源

## 31、服务器出现大量 TIME_WAIT 状态的原因有哪些？
- 第一个场景：HTTP 没有使用长连接
  - 非长连接请求一次就会断开连接导致出现 TIME_WAIT 的状态
- 第二个场景：HTTP 长连接超时
  - 超时断开连接会出现 TIME_WAIT
- 第三个场景：HTTP 长连接的请求数量达到上限
  - 当请求一定次数服务端主动断开连接
 
## 32、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？
- 当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。

## 33、如果已经建立了连接，但是客户端突然出现故障了怎么办？
- TCP 保活机制， 每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡(默认得两个多小时，我们可以自己在应用层实现一个心跳机制)
- web 服务软件一般都会提供 keepalive_timeout：默认60s

## 34、如果已经建立了连接，但是服务端的进程崩溃会发生什么？
- 即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程，由内核代替完成，因为内核需要回收该进程的所有 TCP 连接资源。

## 35、listen 时候参数 backlog 的意义？
- 在 Linux 内核 2.2 之后，通常认为 backlog 是 accept 队列， 上限值是内核参数 somaxconn 的大小

## 36、accept, connect 发生在三次握手的哪一步？
- ![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)
- connect 第二次握手
- accept 三次握手成功之后

## 37、没有 accept，能建立 TCP 连接吗？
- accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket

## 38、没有 listen，能建立 TCP 连接吗？
- 客户端是可以自己连自己的形成连接（TCP自连接）

## 39、重传机制
- 超时重传
  - 设定一个定时器，当超过指定的时间后，就会重发该数据
  - 超时重传时间 RTO 的值应该略大于报文往返 RTT 的值，RTO 动态变化的值。
  - 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍，产生出一个问题，超时周期可能相对较长
- 快速重传(解决超时重传的问题)
  - 不以时间为驱动，而是以数据驱动重传。当收到三个相同的 ACK 报文时，重传丢失的报文段。
  - 面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。
- SACK(以快速重传为基础，解决快速重传的问题)
  - 将已收到的数据的信息发送给「发送方」，这样只需要重传丢失的数据。
- D-SACK
  - 使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。 
  - 使用场景
    - ACK丢包
    - 网络延时
  - 优点
    - 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
    - 可以知道是不是「发送方」的数据包被网络延迟了;
   
## 40、滑动窗口
- TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。
- 接收窗口的大小是约等于发送窗口的大小的。

## 41、流量控制
- TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制

## 42、操作系统缓冲区与滑动窗口的关系
- 接收端因为现在非常的繁忙，操作系统于是就把接收缓存减少了，发送端按照原本的窗口发送数据，结果接收端发现数据大小超过了接收窗口的大小，于是就把数据包丢失了。
- TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况

## 43、窗口关闭
- 如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。
- TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。
- 如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

## 44、糊涂窗口综合症
- 如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。
- 当「窗口大小」小于一定范围后就会向发送方通告窗口为 0，窗口大小必须大于一定范围并且数据大小也大于一定范围才能发送数据
- telnet 或 ssh 这样的交互性比较强的程序除外

## 45、拥塞控制
- 慢启动
  - 发包的个数是指数性的增长。
- 拥塞避免
  - 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。
  - 每次只增加1
- 拥塞发生(网络发生阻塞)
  - 使用超时重传
    - 将慢启动门限 ssthresh 降到拥塞窗口 cwnd 的一半
    - 拥塞窗口 cwnd 变为 1
  - 使用快速重传
    - 将拥塞窗口 cwnd 降到原来的一半
    - 慢启动门限 ssthresh 和 cwnd 相等
    - 随后进入快速恢复状态
- 快速恢复
  - cwnd 加上收到的ACK后进入拥塞避免状态

## 46、如何理解是 TCP 面向字节流协议？
- UDP 协议，操作系统不会对消息进行拆分，每个 UDP 报文就是一个用户消息的边界，用户调用 recvfrom() 取出报文 
- TCP协议，消息可能会被操作系统分组成多个的 TCP 报文，调用 send 函数完成数据“发送”以后只是从应用程序拷贝到了操作系统内核协议栈中。

## 47、如何解决粘包？
- 固定长度的消息
- 特殊字符作为边界(HTTP)
- 自定义消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。

## 48、SYN 报文什么时候情况下会被丢弃？
- 半连接队列(SYN队列)满了且没有开启 synccookies 选项
- 开启 tcp_tw_recycle 且在NAT使用了NAT，客户端 A 和 客户端 B 因为经过相同的 NAT 网关，用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。

## 49、已建立连接的TCP，客户端宕机恢复后，服务端收到SYN会发生什么？
- 客户端的 SYN 报文里的端口号与历史连接不相同：则会重新建立连接。旧连接超时后激活保活机制检测到客户端没有存活后，接着服务端就会释放掉该连接。或者服务端主动发送报文，由于客户端连接已关闭，客户端会回复RST
- 客户端的 SYN 报文里的端口号与历史连接相同：此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数，会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。

## 50、如何关闭一个 TCP 连接？
- killcx 的工具：通过模拟和客户端相同的四元组发送乱序SYN，服务端会回复challenge ACK获取正确的序列号，然后发送RST使得服务端和客户端关闭

## 51、第三次挥手前发送一个数据包，结果第三次挥手的fin包先到会怎么样？
- 因为fin的seq时乱序的，所以fin包会被会加入到「乱序队列」，等收到顺序的数据包后会检查乱序队列里是否有有用的数据

## 52、在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？
- 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大，并且SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要大。那么就会重用该四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。
- 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。那么就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST 报文给服务端。

## 53、TCP 连接，一端断电和进程崩溃有什么区别？
#### 无数据交换
- 主机崩溃(断电)
  - 客户端主机崩溃了，服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。
  - 如果开启 keepalive 当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
- 进程崩溃
  - 即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。
#### 有数据交换
- 客户端主机宕机，又迅速重启
  - 只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。
- 客户端主机宕机，一直没有重启
  - 服务端超时重传报文的次数达到一定阈值后，服务端的 TCP 连接就会断开。
 
## 54、拔掉网线后， 原本的 TCP 连接还存在吗？
- 有数据传输
  - 如果在服务端重传报文的过程中，客户端刚好把网线插回去了，客户端是可以正常接收服务端发来的数据报文的
  - 如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去，务端超时重传报文的次数达到一定阈值后，服务端的 TCP 连接就会断开。
- 无数据传输
  - 没有开启 TCP keepalive 机制，TCP 连接将会一直保持存在。
  - 开启了 TCP keepalive 机制，在持续一段时间后，TCP 就会发送探测报文
    - 当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置
    - 如果对端主机宕机，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
      
## 55、TCP Fast Open
- 第一次客户端和服务端通信的时候，还是需要正常的三次握手流程。随后，客户端就有了 Cookie 这个东西，可以直接请求数据

## 56、TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？
- HTTP 的 Keep-Alive(HTTP长连接，Connection: Keep-Alive)
  - 本来一次连接只请求响应一次，然后断开连接。开启后变成长连接模式，直到某一方主动断开才会断开连接
  - 为了避免资源浪费的情况，web 服务软件一般都会提供 keepalive_timeout 参数，定时器的时间一到，就会触发回调函数来释放该连接。
- TCP 的 Keepalive(TCP保活机制，SO_KEEPALIVE开启)
  - 如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。
    - 如果对端程序是正常工作的。TCP 保活时间会被重置
    - 如果对端主机宕机，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
   
## 57、TCP 协议有什么缺陷？
- 升级 TCP 的工作很困难
- TCP 建立连接的延迟
- TCP 存在队头阻塞问题

## 58、如何基于 UDP 协议实现可靠传输？
- 序列号、确认应答、超时重传、流量控制、拥塞控制 在应用层实现一遍
- QUIC基于HTTP3实现可靠传输
  - Packet Header
    - QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动
  - Frame Header
    - Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；
    - Offset 作用：类似于 TCP 协议中的 Seq 序号，保证数据的顺序性和可靠性；
    - Length 作用：指明了 Frame 数据的长度。
    - 通过 Stream ID + Offset 字段信息实现数据的有序性,丢失的数据包和重传的数据包 Stream ID 与 Offset 都一致，说明这两个数据包的内容一致
- QUIC 是如何解决 TCP 队头阻塞问题的？
  - QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口。
- QUIC 是如何做流量控制的？
  - Stream 级别的流量控制：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制,接受一般滑动窗口就移动
  - Connection 流量控制：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量
- [quic](https://cdn.xiaolincoding.com//mysql/other/http3-over-quic-protocol-works.png)
- [package header](https://cdn.xiaolincoding.com//mysql/other/6a94d41ef3d14cb6b7846e73da6c3104.png)
- [frame](https://cdn.xiaolincoding.com//mysql/other/536298d2c54a43b699026bffe0f85010.png)

## 59、多个 TCP 服务进程可以绑定同一个端口吗？
- 如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。
- 新特性SO_REUSEPORT可以

## 60、重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？
- 当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。
- SO_REUSEADDR 作用是：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功。

## 61、客户端的端口可以重复使用吗？
- 如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的
- IP + PORT 都相同，bind() 时候就会出错
- 只要客户端连接的服务器不同，端口资源可以重复使用的。
[picture](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg)

## 62、服务端没有 listen，客户端发起连接建立，会发生什么？
- 服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。

## 63、不使用 listen ，可以建立 TCP 连接吗？
- 是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。
- 在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。

## 64、没有 accept，能建立 TCP 连接吗？
- 不执行accept()方法，三次握手照常进行，并顺利建立连接。
- accept()只是为了从全连接队列里取出一条连接。

## 65、为什么半连接队列要设计成哈希表
- 全连接队列（icsk_accept_queue）是个链表，而半连接队列（syn_table）是个哈希表。
- 全连接里队列并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了
- 半连接队列等待着第三次握手的到来，现在有一个第三次握手来了则需要从队列里把相应IP端口的连接取出，如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接

## 66、全连接队列满了会怎么样？
- 默认当然会丢弃这个ACK。
- tcp_abort_on_overflow设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的半连接队列里的连接给删掉。
- tcp_abort_on_overflow设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。

## 67、半连接队列要是满了会怎么样
- 一般是丢弃
- 当遇到 SYN Flood 攻击，tcp_syncookies设置为1，客户端发来第一次握手SYN时，服务端不会将其放入半连接队列中，而是直接生成一个cookies，这个cookies会跟着第二次握手，发回客户端。客户端在发第三次握手的时候带上这个cookies
- cookies并不会有一个专门的队列保存，它是通过通信双方的IP地址端口、时间戳、MSS等信息进行实时计算的
- cookies方案虽然能防 SYN Flood攻击，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。
- 如果此时攻击者构造大量的第三次握手包（ACK包），同时带上各种瞎编的cookies信息，服务端收到ACK包后以为是正经cookies，憨憨地跑去解码（耗CPU），最后发现不是正经数据包后才丢弃。

## 68、
