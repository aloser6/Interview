## 内存分配图
- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
= 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 (opens new window)）；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；
- ![picture](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

## 虚拟内存
- CPU -> MMU -> 物理地址 (MMU在CPU里)
- 内存分段
  - 不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。
  - 如果内存交换(内存和磁盘swap)的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。
- 内存分页
  - 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小
  - 采用了分页内存交换的效率就相对比较高。
- 虚拟地址分为两部分，页号和页内偏移
- 多级页表
  - 单个页表占用内存过多

## TLB
- 把最常访问的几个页表项存储到访问速度更快的TLB
- ![picture](https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)

## malloc 是如何分配内存的？
- 当开辟的空间小于 128K 时，调用 brk（）函数，通过移动堆栈指针扩展堆区实现内存分配
- 当开辟的空间大于 128K 时，调用mmap（）函数，在文件映射区实现内存分配
- 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用
- 不全使用brk()是因为假如按顺序分配ABC三块内存，然后释放AB总共30kb，这时又申请40kb，则堆栈只能继续增长，一直这样会产生很多内存碎片，可能会导致内存泄漏

## 内存满了，会发生什么？
- 三种方式
  - 后台内存回收（kswapd，异步）：kswapd 内核线程回收
  - 直接内存回收（direct reclaim，同步）：同步回收的，会阻塞进程
  - 触发 OOM （Out of Memory）机制：对进程任务进行打分，分最高的kill掉
- 三种方式会根据剩余内存大小来进行调整，分别是 页高阈值，页低阈值，页最小阈值

## 哪些内存可以被回收？
- 文件页：回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。
- 匿名页：这部分内存(如堆、栈数据)很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存

## 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？
- 32 位系统的场景(3G用户虚拟内存)
  - 在申请虚拟内存阶段就会失败(cannot allocate memory)
- 64 位系统的场景(128T用户虚拟内存)
  - 物理内存只有 2 GB，但是程序正常分配了 4GB 大小的虚拟内存
  - 原因：lazy allocation
- 没有开启Swap分区我们是不可能申请完整个 128T 的用户空间的，因为程序运行本身也需要申请虚拟空间，申请128T会触发OOM。
- 开启Swap分区则可以正常申请，因为可以把暂时不用的内存放到磁盘

 
