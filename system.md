#### 内存分配图
> 代码段，包括二进制可执行代码；
> 
> 数据段，包括已初始化的静态常量和全局变量；
>
> BSS 段，包括未初始化的静态变量和全局变量；
>
> 堆段，包括动态分配的内存，从低地址开始向上增长；
>
> 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 (opens new window)）；
>
> 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；
>
> ![picture](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

#### 虚拟内存
> CPU -> MMU -> 物理地址 (MMU在CPU里)
>
> 内存分段
>>
>> 不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。
>>
>>如果内存交换(内存和磁盘swap)的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。
>
> 内存分页
>
>> 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小
>
>> 采用了分页内存交换的效率就相对比较高。
>
> 虚拟地址分为两部分，页号和页内偏移
>
> 多级页表
>
>> 单个页表占用内存过多

#### TLB
> 把最常访问的几个页表项存储到访问速度更快的TLB
>
>  ![picture](https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)

#### malloc 是如何分配内存的？
- 当开辟的空间小于 128K 时，调用 brk（）函数，通过移动堆栈指针扩展堆区实现内存分配
- 当开辟的空间大于 128K 时，调用mmap（）函数，在文件映射区实现内存分配
- 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用
- 不全使用brk()是因为假如按顺序分配ABC三块内存，然后释放AB总共30kb，这时又申请40kb，则堆栈只能继续增长，一直这样会产生很多内存碎片，可能会导致内存泄漏

#### 内存满了，会发生什么？
- 三种方式
  - 后台内存回收（kswapd，异步）：kswapd 内核线程回收
  - 直接内存回收（direct reclaim，同步）：同步回收的，会阻塞进程
  - 触发 OOM （Out of Memory）机制：对进程任务进行打分，分最高的kill掉
- 三种方式会根据剩余内存大小来进行调整，分别是 页高阈值，页低阈值，页最小阈值

#### 哪些内存可以被回收？
- 文件页：回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。
- 匿名页：这部分内存(如堆、栈数据)很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存

#### 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？
- 32 位系统的场景(3G用户虚拟内存)
  - 在申请虚拟内存阶段就会失败(cannot allocate memory)
- 64 位系统的场景(128T用户虚拟内存)
  - 物理内存只有 2 GB，但是程序正常分配了 4GB 大小的虚拟内存
  - 原因：lazy allocation
- 没有开启Swap分区我们是不可能申请完整个 128T 的用户空间的，因为程序运行本身也需要申请虚拟空间，申请128T会触发OOM。
- 开启Swap分区则可以正常申请，因为可以把暂时不用的内存放到磁盘

#### 进程、线程和协程的区别和联系
> 切换者
>
> 切换过程
>
> 拥有资源
#### 虚拟技术你了解吗？
> 时（时间）分复用技术：多个进程能在同一个处理器上并发执行使用了时分复用技术
>
> 空（空间）分复用技术：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间
#### 动态分区分配算法有哪几种？可以分别说说吗？
> 首次适应算法：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。
>
> 最佳适应算法：优先使用更小的空闲区。留下太多难以利用的小碎片
>
> 最坏适应算法：优先使用最大的连续空闲区。不能分配大内存
>
> 邻近适应算法：每次都从上次查找结束的位置开始检索。分布均匀不能分配大内存
#### 进程同步的方法？
> 临界区
>
> 同步与互斥
>
> 信号量
#### 虚拟内存的目的是什么？
> 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。
#### 说一下你理解中的内存？他有什么作用呢？
> 程序需要放到内存才能被cpu执行
>
> 如何区分不同程序在内存的什么位置：给内存编地址
#### 介绍一下几种典型的锁？
> 读写锁
> 
> 互斥锁
>
> 条件变量：互斥锁是线程间互斥的机制，条件变量则是同步机制。
>
> 自旋锁
#### 怎么回收线程？有哪几种方法？
> pthread_join
>
> pthread_exit
>
> pthread_detach
#### 内存的覆盖是什么？有什么特点？
> 可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。
> 
> 覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制
#### 如何让进程后台运行
> 命令后面加上&即可
>
> ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程
#### 守护进程、僵尸进程和孤儿进程
 
