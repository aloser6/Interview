## 内存分配图
- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
= 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 (opens new window)）；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；
- [picture](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

## 虚拟内存
- CPU -> MMU -> 物理地址 (MMU在CPU里)
- 内存分段
  - 不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。
  - 如果内存交换(内存和磁盘swap)的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。
- 内存分页
  - 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小
  - 采用了分页内存交换的效率就相对比较高。
- 虚拟地址分为两部分，页号和页内偏移
- 多级页表
  - 单个页表占用内存过多

## TLB
- 把最常访问的几个页表项存储到访问速度更快的TLB
- [picture](https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)

## malloc 是如何分配内存的？
- 当开辟的空间小于 128K 时，调用 brk（）函数，通过移动堆栈指针扩展堆区实现内存分配
- 当开辟的空间大于 128K 时，调用mmap（）函数，在文件映射区实现内存分配
- 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用
