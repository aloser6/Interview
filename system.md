![image](https://github.com/aloser6/Interview/assets/95111754/af3ac4f2-0f11-4571-a0c2-b5841a831141)![image](https://github.com/aloser6/Interview/assets/95111754/4a662312-a0cb-4b0d-9f15-7c1c6635759d)#### 内存分配图
> 代码段，包括二进制可执行代码；
> 
> 数据段，包括已初始化的静态常量和全局变量；
>
> BSS 段，包括未初始化的静态变量和全局变量；
>
> 堆段，包括动态分配的内存，从低地址开始向上增长；
>
> 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 (opens new window)）；
>
> 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；
>
> ![picture](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

#### 虚拟内存
> CPU -> MMU -> 物理地址 (MMU在CPU里)
>
> 内存分段
>>
>> 不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。
>>
>>如果内存交换(内存和磁盘swap)的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。
>
> 内存分页
>
>> 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小
>
>> 采用了分页内存交换的效率就相对比较高。
>
> 虚拟地址分为两部分，页号和页内偏移
>
> 多级页表
>
>> 单个页表占用内存过多

#### TLB
> 把最常访问的几个页表项存储到访问速度更快的TLB
>
>  ![picture](https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)

#### malloc 是如何分配内存的？
- 当开辟的空间小于 128K 时，调用 brk（）函数，通过移动堆栈指针扩展堆区实现内存分配
- 当开辟的空间大于 128K 时，调用mmap（）函数，在文件映射区实现内存分配
- 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用
- 不全使用brk()是因为假如按顺序分配ABC三块内存，然后释放AB总共30kb，这时又申请40kb，则堆栈只能继续增长，一直这样会产生很多内存碎片，可能会导致内存泄漏

#### 内存满了，会发生什么？
- 三种方式
  - 后台内存回收（kswapd，异步）：kswapd 内核线程回收
  - 直接内存回收（direct reclaim，同步）：同步回收的，会阻塞进程
  - 触发 OOM （Out of Memory）机制：对进程任务进行打分，分最高的kill掉
- 三种方式会根据剩余内存大小来进行调整，分别是 页高阈值，页低阈值，页最小阈值

#### 哪些内存可以被回收？
- 文件页：回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。
- 匿名页：这部分内存(如堆、栈数据)很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存

#### 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？
- 32 位系统的场景(3G用户虚拟内存)
  - 在申请虚拟内存阶段就会失败(cannot allocate memory)
- 64 位系统的场景(128T用户虚拟内存)
  - 物理内存只有 2 GB，但是程序正常分配了 4GB 大小的虚拟内存
  - 原因：lazy allocation
- 没有开启Swap分区我们是不可能申请完整个 128T 的用户空间的，因为程序运行本身也需要申请虚拟空间，申请128T会触发OOM。
- 开启Swap分区则可以正常申请，因为可以把暂时不用的内存放到磁盘

#### 进程、线程和协程的区别和联系
> 切换者
>
> 切换过程
>
> 拥有资源
#### 虚拟技术你了解吗？
> 时（时间）分复用技术：多个进程能在同一个处理器上并发执行使用了时分复用技术
>
> 空（空间）分复用技术：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间
#### 动态分区分配算法有哪几种？可以分别说说吗？
> 首次适应算法：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。
>
> 最佳适应算法：优先使用更小的空闲区。留下太多难以利用的小碎片
>
> 最坏适应算法：优先使用最大的连续空闲区。不能分配大内存
>
> 邻近适应算法：每次都从上次查找结束的位置开始检索。分布均匀不能分配大内存
#### 进程同步的方法？
> 临界区
>
> 同步与互斥
>
> 信号量
#### 虚拟内存的目的是什么？
> 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。
#### 说一下你理解中的内存？他有什么作用呢？
> 程序需要放到内存才能被cpu执行
>
> 如何区分不同程序在内存的什么位置：给内存编地址
#### 介绍一下几种典型的锁？
> 读写锁
> 
> 互斥锁
>
> 条件变量：互斥锁是线程间互斥的机制，条件变量则是同步机制。
>
> 自旋锁
#### 怎么回收线程？有哪几种方法？
> pthread_join
>
> pthread_exit
>
> pthread_detach
#### 内存的覆盖是什么？有什么特点？
> 可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。
> 
> 覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制
#### 如何让进程后台运行
> 命令后面加上&即可
>
> ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程
#### 守护进程、僵尸进程和孤儿进程
> 守护进程
> 
>> 调用fork（）产生一个子进程，然后使父进程退出。
>>
>> 调用setsid（）创建一个新对话期，因为控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们
>>
>> 它可以重新申请打开一个终端，所以需要禁止进程重新打开控制终端。通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。
>>
>> 关闭不再需要的文件描述符。
>>
>> 在孙进程中调用 chdir() 函数，让根目录 ”/” 成为孙进程的工作目录
>>
>> 使用unmask（0）将屏蔽字清零。
>>
>> 处理SIGCHLD信号(子进程结束时会发一个SIGCHLD信号)
> 
> 孤儿进程
> 
>> 父进程先退出，子进程的父进程将变为init进程
>
> 僵尸进程
>
>> 子进程退出父进程不回收资源，子进程会变成僵尸进程
#### 如何避免僵尸进程？
> signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收
>
> 父进程调用wait/waitpid等函数等待子进程结束
>
> 父进程可以用signal注册信号处理函数
#### 两大局部性原理
> 时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。
>
> 空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
#### 子进程从父进程继承的有
> 进程的资格(用户号(UIDs)和组号(GIDs)之类的)
>
> 运行环境(environment)，堆栈，内存
>
> 进程组号
#### 为什么只能运行一个前台作业？(作业(job)：一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业)
> 当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。
#### 作业与进程组的区别
> 如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的，但属于进程组。 一旦作业运行结束，shell就把自己提到前台
#### 会话
> 会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。
#### 进程终止的几种方式
> main函数的自然返回
>
> 调用exit函数，属于c标准库
>
> 调用_exit函数，属于系统调用
>
> 调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程
>
> 接受能导致进程终止的信号
#### exit和_exit的区别
> exit会调用中止处理程序并清理io缓冲。_exit是直接到内核
#### Linux中异常和中断的区别
> 产生源不相同，异常是由CPU产生的，而中断主要是由硬件设备产生的
>
> 内核需要根据是异常还是中断调用不同的处理程序
>
> 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中
#### 程序从堆中动态分配内存时，虚拟内存上怎么操作的
> 操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表
>
> 通过PTE建立虚拟页和物理页的映射关系
#### 常见的几种磁盘调度算法
> 先来先服务
>
> 最短寻道时间优先
>
> 电梯扫描算法
#### 抖动你知道是什么吗？它也叫颠簸现象
> 刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数
#### 常见内存分配方式有哪些？
> 静态存储区域分配。栈。堆。
#### 原子操作的是如何实现的
> 总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
>
> 缓存锁就是当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能使用同时缓存i的缓存行
#### 页面置换算法
> 先进先出置换算法(FIFO)
>
> 最近最久未使用置换算法(LRU)
>
> 时钟置换算法(CLOCK)：当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，检查是否为0
#### 死锁的两个常见情形
> 重入导致死锁
>
> 相互等待导致死锁
#### 避免死锁的方法
> 对锁进行排序
#### 内部碎片与外部碎片
> 内碎片：固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；
>
> 外碎片：100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片
#### 如何消除碎片文件
> 内碎片：使一块固定大小的内存更小
> 外碎片：解决外部内存碎片的问题就是内存交换。
