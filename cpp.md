# C++
#### C++11有哪些新特新？
> auto，左值右值，列表初始化，std::function & std::bind & lambda表达式，智能指针
#### 函数有哪些常见的传参方式？有什么区别。
> 传值、传地址、传引用
#### 排序
> 快排：最差O(n^2)，平均(nlogn)
#### new/delete，malloc/free
> new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。
> new -> operator new -> malloc
>
> delete -> operator delete -> free
> 
> [link](https://www.cnblogs.com/ybqjymy/p/12365773.html)
#### 如何让类只能在堆内存上开辟
> 让析构函数private，编译器就不会在栈上分配内存
>
> [link](https://blog.csdn.net/baidu_16370559/article/details/123330995)
#### 引用的引用
> 因为引用本身不是一个对象，所以不能定义引用的引用。
>
> [link](https://blog.csdn.net/gabriella9655/article/details/108331298)
#### explicit
> 让构造函数/转换函数必须显示调用，防止隐式转换
#### 为什么模板声明和定义不能分开写
> 普通函数定义和声明放在不同文件里，编译器看到声明后会将其加入外部符号表，链接时就能找到他的定义
>
> 对于模板函数，如果定义和声明放在不同文件里，编译时遇到调用模板的地方，由于定义和声明不在同一文件，所有仅仅只是将声明加入外部符号表，而不会实例化调用类型的代码，当链接时就会找不到对应的代码
#### 类的前置声明
> 当A使用B，B使用A时需要B先声明一下，这样才能编译通过
> 
> 当A在上面的基础上，A使用了b的定义，比如成员函数，这时候会报错，因为前置声明仅仅是声明，解决方法，声明和定义分开写
>
> [link](https://www.cnblogs.com/dobben/p/7440745.html)
#### override和final
> override是用来检测是否成功重写了父类的虚函数
>
> final修饰虚函数防止子类重写虚函数。修饰类防止别的类继承。
#### 重写/覆盖(override)和隐藏(hide)的区别
> 重写要加virtual，隐藏不需要
#### 构造函数列表初始化和赋值的区别
> 更高效，直接对成员变量进行初始化，避免了额外的赋值操作。
#### 有哪些情况必须要通过列表初始化
> const类型，引用类型
#### 左值右值
> move只能左转右。forward既能左转右，也能右转左。
>
> [link](https://zhuanlan.zhihu.com/p/335994370)
>
> [link](https://www.cnblogs.com/david-china/p/17080072.html)
#### 智能指针底层
> 引用计数+裸指针
#### 信号量底层
> 条件变量+互斥锁
#### 空指针，野指针，悬垂指针
> 空指针指向空，野指针指向未知内存，悬垂指针所指向的内存区域已释放，生命周期已经结束
#### 智能指针底层
> 引用计数+裸指针
#### 智能指针相互转换
> weak->shared  weak.lock()
> 
> unique->shared  move(unique)
#### unique_ptr转移权限
> move
#### unique_ptr释放权限
> release
#### 智能指针reset
> 释放原本的内存对象并指向新的指针对象
#### shared_ptr存在的问题
> 安全返回this指针
>
> 循环引用
#### weak_ptr能否直接调用定义
> 不能，因为引用计数为0
#### 静态多态和动态多态的实现原理
#### 有无虚函数时类的大小，为什么大
> 大一个虚函数指针的大小
#### 模板的泛化，特化，偏特化，全特化
> 泛化是一个通用模板，适用于多种类型
>
> 特化是指部分或者全部参数都指定的模板实例化
>
> 偏特化是部分参数指定的模板实例化
>
> 全特化是全部参数指定的模板实例化
#### 模板的分类
> 函数模板，类模板
#### 模板参数的推导过程
#### 限制模板参数传入的类型
> static_assert断言
#### explicit使用场景
> 防止类构造函数自动隐式转化。当只有一个参数或者除第一个参数外都有默认值
#### define和inline
> inline会类型检查，define不会
>
> inline在编译器，define在预处理期
#### volatile应用场景
#### mutable的作用
> 使一个变量变成可变的状态，比如const修饰的成员函数和mutable修饰的成员变量，在成员函数里就能修改这个变量
#### const修饰成员函数的两种作用
> 提示作用，让成员函数不能修改成员变量
>
> 使得该函数只能调用const成员函数
#### 设计模式//TODO
#### 动态链接和静态链接的区别
#### static和static const在内存的哪个区
#### 管道的原理
> 底层是一个环形缓冲区，并有读指针和写指针，写的时候写指针向前移动，读的时候读指针向前移动，没数据是阻塞
#### 管道的分类和区别
> 匿名管道：只能在父子进程之间使用
>
> 有名管道：可以在不同进程之间使用的管道
#### 信号量实现进程间通信
> //TODO
#### 共享内存和管道的区别 //TODO
#### 管道底层已经保证线程安全，共享内存没有保证线程安全，如果要保证线程安全该怎么做，或者说进程间同步该怎么做 //TODO
#### io多路复用的区别
#### 三种内核调度策略及调度原理
> 先来先作业，短作业优先，时间片轮转调度
#### 协程的原理
> //TODO
#### 锁和信号量的应用场景/区别
> 锁没有顺序，信号量有顺序
#### python unittest
#### 结构体内存对齐问题
> alignas,alignof
#### 一个指针占多少字节
> 跟编译环境有关，而与机器的位数无关
#### const和static的作用
> static
>> 不考虑类
>> 
>>>有全局可见性,具有记忆性
>>>
>> 考虑类
>> 
>>>static成员变量:定义时要分配空间，不能在类声明中初始化
>>>
>>>static成员函数:不具有this指针，无法访问类对象的非static成员变量和非static成员函数
>
> const
>>不考虑类的情况
>>
>>>只能通过构造函数初始化列表进行初始化(引用也是)
>>>
>>考虑类的情况
>>>
>>>const对象不可以调用非const成员函数
#### 数组名和指针的区别
> 数组名没有自增、自减等操作
#### 转换构造函数
> 当只有一个参数的时候，用于类型转换
#### 如何用代码判断大小端存储？
> int转char，只留下低位
#### 什么情况下会调用拷贝构造函数
> 用类的一个实例化对象去初始化另一个对象的时候
> 函数的参数是类的对象时
> 函数的返回值是函数体内局部对象的类的对象时(无NRV优化时)
#### cpp的new种类
> new, nothrow new, placement new(不分配内存，只调用构造)
#### malloc、realloc、calloc的区别
> calloc：省去认为计算申请内存的大小
>
> realloc：给原本的内存扩容
#### 类成员初始化方式
> 赋值初始化：是在所有的数据成员被分配内存空间后才进行的。
>
> 列表初始化：分配内存空间时就进行初始化
#### 有哪些情况必须用到成员列表初始化
> 引用，常量，基类构造函数，成员类构造函数
#### string和char*的区别
> string继承自basic_string,其实是对char*进行了封装
>
> string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。
#### 成员初始化列表的概念，为什么用它会快一些？
> 对于内置类型没什么影响
>
> 如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值(有参构造函数)，而初始化列表只做一次赋值操作(有参构造函数)
#### C++函数调用的压栈过程
> 保存当前函数的执行状态
>
> 压入参数(右->左)
>
> 压入返回地址
>
> 压入esp，调整esp
#### 类的对象存储空间？
> 非静态成员的数据类型大小之和。
>
> 编译器加入的额外成员变量（如指向虚函数表的指针）。
#### 如果在类的析构函数中调用delete this，会发生什么？
> 堆栈溢出，系统崩溃
#### 迭代器：++it、it++哪个好，为什么
> 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低
#### Vector如何释放空间?
> clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。
>
> 如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存
#### 容器内部删除一个元素
> 顺序容器（序列式容器，比如vector、deque）
>>
>> erase的返回值是下一个有效迭代器；
>>
> 关联容器(关联式容器，比如map、set、multimap、multiset等)
>>
>> erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；
#### 动态分区分配算法有哪几种？可以分别说说吗？
> 首次适应算法：因为顺序遍历，容易低地址存小内存，高地址存大内存
>
> 最佳适应算法：对空闲分区表/链进行排序，每次取最小，容易产生内存碎片
>
> 最坏适应算法：排序，每次取最大，解决内存碎片但是不能存大内存
>
> 邻近适应算法：从上一次分配的点进行分配，内粗分配均匀，不能分配大内存
#### 进程同步的四种方法？
> 临界区
>
> 同步与互斥
>
> 信号量
#### this指针详解
> 为什么不能直接返回this：如果返回this会用一个外部变量来存储，当对象被析构，外部变量感知不到对象已被析构，继续使用可能导致程序崩溃，所以要使用shared_ptr
>
> 为什么不能直接使用shared_ptr返回this指针：指向对象的shared_ptr和接受this的shared_ptr并不共享引用计数，从而导致构造一次析构两次的情况，所以需要继承enable_shared_from_this才能安全返回
> 
> 为什么成员函数不能同时使用const和static：const表示在该函数体内不能修改成员的值，会在函数中添加一个隐式的参数const this*。static修饰的函数没有this指针，与const的用法冲突。
>
> 为什么要有this：一个类中的不同对象在调用自己的成员函数时，其实它们调用的是同一段函数代码，那么成员函数如何知道要访问哪个对象的数据成员
>
> C++中this关键字是一个指向对象自己的一个常量指针，不能给this赋值
>
> enable_shared_from_this底层实现
>
> [link](https://www.cnblogs.com/yuwanxian/p/10988736.html)
>
> [link](https://iliubang.cn/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/)
>
> [link](https://www.cnblogs.com/goya/p/11967200.html)
#### 线程和进程共享什么


# STL
#### STL六大组件
> 容器
>
> 算法
>
> 迭代器
>
> 配接器：用来修饰容器或迭代器接口的东西
>
> 仿函数：重载了operator()行为类似函数的函数
>
> 配置器：分配/释放内存
>
> [Link](https://blog.csdn.net/daaikuaichuan/article/details/80717222)
#### array 和 vector 的区别
> array定长数组, vector动态开辟
#### push_back和emplace_back的区别
> push_back添加一个元素先构造，然后拷贝/移动到容器里，然后将原本的删除
> 
> emplace_back添加一个元素直接再容器末尾构造，不需要拷贝/移动
#### push_back和emplace_back的没有区别
> 基础类型
>
> //TODO
#### 主动扩容
> reserve改变容器大小，resize改变存储元素个数
#### resize超过容器大小会发生什么
> 会将容器大小扩展到对应大小
#### map插入有哪几种方式
> insert，emplace，下标
#### insert和emplace的差别
> insert先创建键值对然后拷贝/移动到容器内
>
> emplace直接在容器内创建键值对
>
> 下标插入如果键存在则会直接覆盖不会有任何指示
#### insert
> insert返回pair，第一个元素是所指向的迭代器，第二个元素返回是否成功插入(如果键已经存在则插入失败)
#### 怎么对map进行排序规则的更改
> 写一个仿函数，类里面写bool operate()
#### C++中将临时变量作为返回值时的处理过程
> 临时变量压入栈，返回值放在寄存器里
#### 如何获得结构成员相对于结构开头的字节偏移量
> offsetof宏
#### 指针加减计算要注意什么？
> 移动的步长跟指针的类型是有关系的
#### 怎样判断两个浮点数是否相等？
> 对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值
#### 类如何实现只能静态分配和只能动态分配
> 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建
#### 如果想将某个类用作基类，为什么该类必须定义而非声明？
> 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。
#### 函数调用过程栈的变化，返回值和参数变量哪个先入栈？
> 从右向左依次把被调函数所需要的参数压入栈
>
> 调用者函数使用call指令调用被调函数，调用者函数使用call指令调用被调函数
>
> 保存调用者函数的栈底地址
>
> 存放被调函数中的局部变量和临时变量
#### printf函数的实现原理
> printf的第一个被找到的参数就是那个字符指针
>
> 通过判断字符串里控制参数的个数来判断参数个数及数据类
#### cout和printf有什么区别？
> cout<<是类std::ostream的全局对象
#### strcpy和memcpy的区别
> strcpy只能复制字符串，而memcpy可以复制任意内容
#### 什么情况用指针当参数，什么时候用引用
> 数组，则使用指针
>
> 类对象，则使用const引用
#### 成员初始化列表会在什么时候用到
> 引用
>
> 指针
>
> 基类
>
> 成员类
#### 如何禁止程序自动生成拷贝构造函数
> 定一个base类，base类中将拷贝构造函数和拷贝赋值函数设置成private
#### memset(this,0,sizeof(*this))会发生什么
> 整个对象的内存全部置为0
>
> 类含有虚函数表，会破坏虚函数表
#### 动态编译与静态编译
> 静态编译：编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去
>
> 动态编译：动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令
#### delete和delete[]区别
> delete只会调用一次析构函数
>
> delete[]每个元素都会调用一次析构函数
#### STL的两级空间配置器
> 默认选择的为二级空间配置器。 如果大于128字节再转去一级配置器器
>
> 一级配置器： 一级空间配置器是以malloc()，free() 等执行实际的内存配置
>
> 二级配置器：[Link](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-04-01-STL.html)
#### 容器内部删除一个元素
> 顺序容器（序列式容器，比如vector、deque）：erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；
>
> 关联容器(关联式容器，比如map、set、multimap、multiset等)：erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；
#### STL迭代器如何实现
> 迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历
#### map插入方式有哪几种？
> 用insert函数插入pair数据
>
> 用数组方式插入数据
#### unordered_map(hash_map)和map的区别
#### 什么是虚拟继承
> 虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体
>
>  A
>
> /\
>
> B C
>
> \/
>
>  D
#### 构造函数析构函数的执行顺序构造函数和拷贝构造的内部都干了啥
> 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序
> 
> 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序
>
> 派生类构造函数
#### 构造函数的执行顺序是什么
> 在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；
>
> 对象的vptr被初始化；
>
> 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；
>
> 执行程序员所提供的代码；
#### 哪些函数不能是虚函数把你知道的都说一说
> 构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；
>
> 内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
>
> 静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。
>
> 友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
>
> 普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。




#设计模式
#### 单例模式
> 懒汉版
>> 防止内存泄漏：使用只能指针(使用静态的嵌套类对象？)
>>
>> 防止线程不安全：双重锁
>
> 饿汉版
>> main函数执行前就创建好对象
#### 工厂模式
> 简单工厂：同一系列的不同产品使用同一工厂
>
> 缺点：可扩展性差，新增时就要更改工厂的代码
>
> 工厂方法：同一系列的不同产品使用不同的工厂
>
> 缺点：不能生产不同系列的产品
>
> 抽象工厂：不同系列的不同产品使用不同工厂
>
> [Link](https://blog.csdn.net/m0_46308273/article/details/117126962)
#### 观察者模式
> 观察者：class ObserverInterface{ virtual void dosomething()=0; };
>
> 被观察者：class SubjectInterface{ virtual void Add(ObserverInterface* obr)=0; virtual void Remove(ObserverInterface* obr)=0; virtual void Notify()=0; }
#### 中介者
> ![picture](https://img-blog.csdnimg.cn/20200518161338131.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70)
>
> [Link](https://blog.csdn.net/cpp_learner/article/details/106192950)
>
> 优点：达到程序解耦的目的
#### 适配器模式
> 将一个类的接口转换成客户希望的另外接口
> 
> [Link](https://blog.csdn.net/ahelloyou/article/details/123264127)



# Linux操作系统
#### 互斥锁和自旋锁的区别
> 互斥锁阻塞，自旋锁忙等
#### 阻塞和挂起的区别
> 阻塞：线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才回复运行
> 
> 挂起：机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存
#### 如何实现守护进程
#### 六种进程间通信的效率排名
> 共享内存，管道，消息队列，信号量，信号，socket套接字
#### IO多路复用
> select：需要将fds_set从用户态拷贝到内核，fd越多拷贝的越多。内核需要遍历所有文件描述符。且上限是1024。fds集合不能重用每次都要重置。
>
> poll：在select的基础上改善了上限。
>
> epoll
>> 水平触发(LT)
>> 
>> 边缘触发(ET)
#### malloc
> [Link](https://www.cnblogs.com/ssezhangpeng/p/10808969.html)
#### 无锁队列
> [Link](https://blog.csdn.net/lucky52529/article/details/101162787)
#### 内存分布
> cpp
>> 栈
>>
>> 文件映射区(可用于加载动态库/动态申请内存(大于128k))
>>
>> 堆
>>
>> 全局区(包括 未初始化的全局变量/静态变量(.bss)， 已初始化的全局变量/静态变量(.data))
>>
>> 常量区(虚表)
>> 
>> 代码段(包括 代码和只读变量)
>
> linux/c
> 
>> 栈
>>
>> 文件映射区
>>
>> 堆
>>
>> .Bss
>>
>> .Data
>>
>> 代码段
#### select改文件描述符上限
> 通过宏定义
#### 线程比协程的优点
> 
#### io多路复用底层实现
>
