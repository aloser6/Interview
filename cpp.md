# C++
### C++11有哪些新特新？
> auto，左值右值，列表初始化，std::function & std::bind & lambda表达式，智能指针
### 函数有哪些常见的传参方式？有什么区别。
> 传值、传地址、传引用
### 排序
> 快排：最差O(n^2)，平均(nlogn)
### new/delete，malloc/free
> new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。
> new -> operator new -> malloc
>
> delete -> operator delete -> free
> 
> [link](https://www.cnblogs.com/ybqjymy/p/12365773.html)
### 如何让类只能在堆内存上开辟
> 让析构函数private，编译器就不会在栈上分配内存
>
> [link](https://blog.csdn.net/baidu_16370559/article/details/123330995)
### 引用的引用
> 因为引用本身不是一个对象，所以不能定义引用的引用。
>
> [link](https://blog.csdn.net/gabriella9655/article/details/108331298)
### explicit
> 让构造函数/转换函数必须显示调用，防止隐式转换
### 为什么模板声明和定义不能分开写
> 普通函数定义和声明放在不同文件里，编译器看到声明后会将其加入外部符号表，链接时就能找到他的定义
>
> 对于模板函数，如果定义和声明放在不同文件里，编译时遇到调用模板的地方，由于定义和声明不在同一文件，所有仅仅只是将声明加入外部符号表，而不会实例化调用类型的代码，当链接时就会找不到对应的代码
### 类的前置声明
> 当A使用B，B使用A时需要B先声明一下，这样才能编译通过
> 
> 当A在上面的基础上，A使用了b的定义，比如成员函数，这时候会报错，因为前置声明仅仅是声明，解决方法，声明和定义分开写
>
> [link](https://www.cnblogs.com/dobben/p/7440745.html)
### override和final
> override是用来检测是否成功重写了父类的虚函数
>
> final修饰虚函数防止子类重写虚函数。修饰类防止别的类继承。
### 重写(override)和覆盖(overload)的区别
> 重写要加virtual，覆盖不需要
### 构造函数列表初始化和赋值的区别
> 更高效，直接对成员变量进行初始化，避免了额外的赋值操作。
### 有哪些情况必须要通过列表初始化
> const类型，引用类型
### 左值右值
> move只能左转右。forward既能左转右，也能右转左。
>
> [link](https://zhuanlan.zhihu.com/p/335994370)
### 智能指针底层
> 引用计数+裸指针
### 信号量底层
> 条件变量+互斥锁
### 空指针，野指针，悬垂指针
> 空指针指向空，野指针指向未知内存，悬垂指针所指向的内存区域已释放，生命周期已经结束
### 智能指针底层
> 引用计数+裸指针
### 智能指针相互转换
> weak->shared  weak.lock()
> 
> unique->shared  move(unique)

# STL
### STL六大组件
> 容器
>
> 算法
>
> 迭代器
>
> 配接器：用来修饰容器或迭代器接口的东西
>
> 仿函数：重载了operator()行为类似函数的函数
>
> 配置器：分配/释放内存
>
> [Link](https://blog.csdn.net/daaikuaichuan/article/details/80717222)
### array 和 vector 的区别
> array定长数组, vector动态开辟
### push_back和emplace_back的区别
> push_back添加一个元素先构造，然后拷贝/移动到容器里，然后将原本的删除
> 
> emplace_back添加一个元素直接再容器末尾构造，不需要拷贝/移动


# Linux操作系统
### 互斥锁和自旋锁的区别
> 互斥锁阻塞，自旋锁忙等
### 阻塞和挂起的区别
> 阻塞：线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才回复运行
> 
> 挂起：机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存
### 如何实现守护进程
### 进程间通信
> 管道
> 
> 信号量
>
> 共享内存
>
> 消息队列
>
> socket通信
### IO多路复用
> select：需要将fds_set从用户态拷贝到内核，fd越多拷贝的越多。内核需要遍历所有文件描述符。且上限是1024。fds集合不能重用每次都要重置。
>
> poll：在select的基础上改善了上限。
>
> epoll
>> 水平触发(LT)
>> 
>> 边缘触发(ET)
### malloc
> [Link](https://www.cnblogs.com/ssezhangpeng/p/10808969.html)
### 无锁队列
> [Link](https://blog.csdn.net/lucky52529/article/details/101162787)
### 内存分布
> 栈
>
> 文件映射区(可用于加载动态库/动态申请内存(大于128k))
>
> 堆
>
> 全局区(包括 未初始化的全局变量/静态变量(.bss)， 已初始化的全局变量/静态变量(.data))
>
> 常量区(虚表)
> 
> 代码段(包括 代码和只读变量)
### select改文件描述符上限
> 通过宏定义
### 线程比协程的优点
> 
### io多路复用底层实现
> 
