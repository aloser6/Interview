# C++
#### C++11有哪些新特新？
> auto，左值右值，列表初始化，std::function & std::bind & lambda表达式，智能指针
#### 函数有哪些常见的传参方式？有什么区别。
> 传值、传地址、传引用
#### 排序
> 快排：最差O(n^2)，平均(nlogn)
#### new/delete，malloc/free
> new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。
> new -> operator new -> malloc
>
> delete -> operator delete -> free
> 
> [link](https://www.cnblogs.com/ybqjymy/p/12365773.html)
#### 如何让类只能在堆内存上开辟
> 让析构函数private，编译器就不会在栈上分配内存
>
> [link](https://blog.csdn.net/baidu_16370559/article/details/123330995)
#### 引用的引用
> 因为引用本身不是一个对象，所以不能定义引用的引用。
>
> [link](https://blog.csdn.net/gabriella9655/article/details/108331298)
#### explicit
> 让构造函数/转换函数必须显示调用，防止隐式转换
#### 为什么模板声明和定义不能分开写
> 普通函数定义和声明放在不同文件里，编译器看到声明后会将其加入外部符号表，链接时就能找到他的定义
>
> 对于模板函数，如果定义和声明放在不同文件里，编译时遇到调用模板的地方，由于定义和声明不在同一文件，所有仅仅只是将声明加入外部符号表，而不会实例化调用类型的代码，当链接时就会找不到对应的代码
#### 类的前置声明
> 当A使用B，B使用A时需要B先声明一下，这样才能编译通过
> 
> 当A在上面的基础上，A使用了b的定义，比如成员函数，这时候会报错，因为前置声明仅仅是声明，解决方法，声明和定义分开写
>
> [link](https://www.cnblogs.com/dobben/p/7440745.html)
#### override和final
> override是用来检测是否成功重写了父类的虚函数
>
> final修饰虚函数防止子类重写虚函数。修饰类防止别的类继承。
#### 重写(override)和覆盖(overload)的区别
> 重写要加virtual，覆盖不需要
#### 构造函数列表初始化和赋值的区别
> 更高效，直接对成员变量进行初始化，避免了额外的赋值操作。
#### 有哪些情况必须要通过列表初始化
> const类型，引用类型
#### 左值右值
> move只能左转右。forward既能左转右，也能右转左。
>
> [link](https://zhuanlan.zhihu.com/p/335994370)
#### 智能指针底层
> 引用计数+裸指针
#### 信号量底层
> 条件变量+互斥锁
#### 空指针，野指针，悬垂指针
> 空指针指向空，野指针指向未知内存，悬垂指针所指向的内存区域已释放，生命周期已经结束
#### 智能指针底层
> 引用计数+裸指针
#### 智能指针相互转换
> weak->shared  weak.lock()
> 
> unique->shared  move(unique)
#### unique_ptr转移权限
> move
#### unique_ptr释放权限
> release
#### 智能指针reset
> 释放原本的内存对象并指向新的指针对象
#### shared_ptr存在的问题
> 安全返回this指针
>
> 循环引用
#### weak_ptr能否直接调用定义
> 不能，因为引用计数为0
#### 静态多态和动态多态的实现原理
#### 有无虚函数时类的大小，为什么大
> 大一个虚函数指针的大小
#### 模板的泛化，特化，偏特化，全特化
> 泛化是一个通用模板，适用于多种类型
>
> 特化是指部分或者全部参数都指定的模板实例化
>
> 偏特化是部分参数指定的模板实例化
>
> 全特化是全部参数指定的模板实例化
#### 模板的分类
> 函数模板，类模板
#### 模板参数的推导过程
#### 限制模板参数传入的类型
> static_assert断言
#### explicit使用场景
> 防止类构造函数自动隐式转化。当只有一个参数或者除第一个参数外都有默认值
#### define和inline
> inline会类型检查，define不会
>
> inline在编译器，define在预处理期
#### volatile应用场景
#### mutable的作用
> 使一个变量变成可变的状态，比如const修饰的成员函数和mutable修饰的成员变量，在成员函数里就能修改这个变量
#### const修饰成员函数的两种作用
> 提示作用，让成员函数不能修改成员变量
>
> 使得该函数只能调用const成员函数
#### 设计模式//TODO
#### 动态链接和静态链接的区别
#### static和static const在内存的哪个区
#### 管道的原理
> 底层是一个环形缓冲区，并有读指针和写指针，写的时候写指针向前移动，读的时候读指针向前移动，没数据是阻塞
#### 管道的分类和区别
> 匿名管道：只能在父子进程之间使用
>
> 有名管道：可以在不同进程之间使用的管道
#### 信号量实现进程间通信
> //TODO
#### 共享内存和管道的区别 //TODO
#### 管道底层已经保证线程安全，共享内存没有保证线程安全，如果要保证线程安全该怎么做，或者说进程间同步该怎么做 //TODO
#### 五种进程间通信的效率排名
> 管道，信号量，消息队列，共享内存，socket编程
#### io多路复用的区别
#### 三种内核调度策略及调度原理
> 先来先作业，短作业优先，时间片轮转调度
#### 协程的原理
> //TODO
#### 锁和信号量的应用场景/区别
> 锁没有顺序，信号量有顺序
#### python unittest

# STL
#### STL六大组件
> 容器
>
> 算法
>
> 迭代器
>
> 配接器：用来修饰容器或迭代器接口的东西
>
> 仿函数：重载了operator()行为类似函数的函数
>
> 配置器：分配/释放内存
>
> [Link](https://blog.csdn.net/daaikuaichuan/article/details/80717222)
#### array 和 vector 的区别
> array定长数组, vector动态开辟
#### push_back和emplace_back的区别
> push_back添加一个元素先构造，然后拷贝/移动到容器里，然后将原本的删除
> 
> emplace_back添加一个元素直接再容器末尾构造，不需要拷贝/移动
#### push_back和emplace_back的没有区别
> 基础类型
>
> //TODO
#### 主动扩容
> reserve改变容器大小，resize改变存储元素个数
#### resize超过容器大小会发生什么
> 会将容器大小扩展到对应大小
#### map插入有哪几种方式
> insert，emplace，下标
#### insert和emplace的差别
> insert先创建键值对然后拷贝/移动到容器内
>
> emplace直接在容器内创建键值对
>
> 下标插入如果键存在则会直接覆盖不会有任何指示
#### insert
> insert返回pair，第一个元素是所指向的迭代器，第二个元素返回是否成功插入(如果键已经存在则插入失败)
#### 怎么对map进行排序规则的更改
> 写一个仿函数，类里面写bool operate()




# Linux操作系统
#### 互斥锁和自旋锁的区别
> 互斥锁阻塞，自旋锁忙等
#### 阻塞和挂起的区别
> 阻塞：线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才回复运行
> 
> 挂起：机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存
#### 如何实现守护进程
#### 进程间通信
> 管道
> 
> 信号量
>
> 共享内存
>
> 消息队列
>
> socket通信
#### IO多路复用
> select：需要将fds_set从用户态拷贝到内核，fd越多拷贝的越多。内核需要遍历所有文件描述符。且上限是1024。fds集合不能重用每次都要重置。
>
> poll：在select的基础上改善了上限。
>
> epoll
>> 水平触发(LT)
>> 
>> 边缘触发(ET)
#### malloc
> [Link](https://www.cnblogs.com/ssezhangpeng/p/10808969.html)
#### 无锁队列
> [Link](https://blog.csdn.net/lucky52529/article/details/101162787)
#### 内存分布
> cpp
>> 栈
>>
>> 文件映射区(可用于加载动态库/动态申请内存(大于128k))
>>
>> 堆
>>
>> 全局区(包括 未初始化的全局变量/静态变量(.bss)， 已初始化的全局变量/静态变量(.data))
>>
>> 常量区(虚表)
>> 
>> 代码段(包括 代码和只读变量)
> linux/c
>> 栈
>>
>> 文件映射区
>>
>> 堆
>>
>> .Bss
>>
>> .Data
>>
>> 代码段
#### select改文件描述符上限
> 通过宏定义
#### 线程比协程的优点
> 
#### io多路复用底层实现
> 
