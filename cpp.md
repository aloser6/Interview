# C++
#### C++11有哪些新特新？
> auto，左值右值，列表初始化，std::function & std::bind & lambda表达式，智能指针
#### 函数有哪些常见的传参方式？有什么区别。
> 传值、传地址、传引用
#### 排序
> 快排：最差O(n^2)，平均(nlogn)
#### new/delete，malloc/free
> new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。
> new -> operator new -> malloc
>
> delete -> operator delete -> free
> 
> [link](https://www.cnblogs.com/ybqjymy/p/12365773.html)
#### 如何让类只能在堆内存上开辟
> 让析构函数private，编译器就不会在栈上分配内存
>
> [link](https://blog.csdn.net/baidu_16370559/article/details/123330995)
#### 引用的引用
> 因为引用本身不是一个对象，所以不能定义引用的引用。
>
> [link](https://blog.csdn.net/gabriella9655/article/details/108331298)
#### explicit
> 让构造函数/转换函数必须显示调用，防止隐式转换
#### 为什么模板声明和定义不能分开写
> 普通函数定义和声明放在不同文件里，编译器看到声明后会将其加入外部符号表，链接时就能找到他的定义
>
> 对于模板函数，如果定义和声明放在不同文件里，编译时遇到调用模板的地方，由于定义和声明不在同一文件，所有仅仅只是将声明加入外部符号表，而不会实例化调用类型的代码，当链接时就会找不到对应的代码
#### 类的前置声明
> 当A使用B，B使用A时需要B先声明一下，这样才能编译通过
> 
> 当A在上面的基础上，A使用了b的定义，比如成员函数，这时候会报错，因为前置声明仅仅是声明，解决方法，声明和定义分开写
>
> [link](https://www.cnblogs.com/dobben/p/7440745.html)
#### override和final
> override是用来检测是否成功重写了父类的虚函数
>
> final修饰虚函数防止子类重写虚函数。修饰类防止别的类继承。
#### 重写/覆盖(override)和隐藏(hide)的区别
> 重写要加virtual，隐藏不需要
#### 构造函数列表初始化和赋值的区别
> 更高效，直接对成员变量进行初始化，避免了额外的赋值操作。
#### 有哪些情况必须要通过列表初始化
> const类型，引用类型
#### 左值右值
> move只能左转右。forward既能左转右，也能右转左。
>
> [link](https://zhuanlan.zhihu.com/p/335994370)
#### 智能指针底层
> 引用计数+裸指针
#### 信号量底层
> 条件变量+互斥锁
#### 空指针，野指针，悬垂指针
> 空指针指向空，野指针指向未知内存，悬垂指针所指向的内存区域已释放，生命周期已经结束
#### 智能指针底层
> 引用计数+裸指针
#### 智能指针相互转换
> weak->shared  weak.lock()
> 
> unique->shared  move(unique)
#### unique_ptr转移权限
> move
#### unique_ptr释放权限
> release
#### 智能指针reset
> 释放原本的内存对象并指向新的指针对象
#### shared_ptr存在的问题
> 安全返回this指针
>
> 循环引用
#### weak_ptr能否直接调用定义
> 不能，因为引用计数为0
#### 静态多态和动态多态的实现原理
#### 有无虚函数时类的大小，为什么大
> 大一个虚函数指针的大小
#### 模板的泛化，特化，偏特化，全特化
> 泛化是一个通用模板，适用于多种类型
>
> 特化是指部分或者全部参数都指定的模板实例化
>
> 偏特化是部分参数指定的模板实例化
>
> 全特化是全部参数指定的模板实例化
#### 模板的分类
> 函数模板，类模板
#### 模板参数的推导过程
#### 限制模板参数传入的类型
> static_assert断言
#### explicit使用场景
> 防止类构造函数自动隐式转化。当只有一个参数或者除第一个参数外都有默认值
#### define和inline
> inline会类型检查，define不会
>
> inline在编译器，define在预处理期
#### volatile应用场景
#### mutable的作用
> 使一个变量变成可变的状态，比如const修饰的成员函数和mutable修饰的成员变量，在成员函数里就能修改这个变量
#### const修饰成员函数的两种作用
> 提示作用，让成员函数不能修改成员变量
>
> 使得该函数只能调用const成员函数
#### 设计模式//TODO
#### 动态链接和静态链接的区别
#### static和static const在内存的哪个区
#### 管道的原理
> 底层是一个环形缓冲区，并有读指针和写指针，写的时候写指针向前移动，读的时候读指针向前移动，没数据是阻塞
#### 管道的分类和区别
> 匿名管道：只能在父子进程之间使用
>
> 有名管道：可以在不同进程之间使用的管道
#### 信号量实现进程间通信
> //TODO
#### 共享内存和管道的区别 //TODO
#### 管道底层已经保证线程安全，共享内存没有保证线程安全，如果要保证线程安全该怎么做，或者说进程间同步该怎么做 //TODO
#### io多路复用的区别
#### 三种内核调度策略及调度原理
> 先来先作业，短作业优先，时间片轮转调度
#### 协程的原理
> //TODO
#### 锁和信号量的应用场景/区别
> 锁没有顺序，信号量有顺序
#### python unittest
#### 结构体内存对齐问题
> alignas,alignof
#### 一个指针占多少字节
> 跟编译环境有关，而与机器的位数无关
#### const和static的作用
> static
>> 不考虑类
>> 
>>>有全局可见性,具有记忆性
>>>
>> 考虑类
>> 
>>>static成员变量:定义时要分配空间，不能在类声明中初始化
>>>
>>>static成员函数:不具有this指针，无法访问类对象的非static成员变量和非static成员函数
>
> const
>>不考虑类的情况
>>
>>>只能通过构造函数初始化列表进行初始化(引用也是)
>>>
>>考虑类的情况
>>>
>>>const对象不可以调用非const成员函数
#### 数组名和指针的区别
> 数组名没有自增、自减等操作
#### 转换构造函数
> 当只有一个参数的时候，用于类型转换
#### 如何用代码判断大小端存储？
> int转char，只留下低位
#### 什么情况下会调用拷贝构造函数
> 用类的一个实例化对象去初始化另一个对象的时候
> 函数的参数是类的对象时
> 函数的返回值是函数体内局部对象的类的对象时(无NRV优化时)
#### cpp的new种类
> new, nothrow new, placement new(不分配内存，只调用构造)
#### malloc、realloc、calloc的区别
> calloc：省去认为计算申请内存的大小
>
> realloc：给原本的内存扩容
#### 类成员初始化方式
> 赋值初始化：是在所有的数据成员被分配内存空间后才进行的。
>
> 列表初始化：分配内存空间时就进行初始化
#### 有哪些情况必须用到成员列表初始化
> 引用，常量，基类构造函数，成员类构造函数
#### string和char*的区别
> string继承自basic_string,其实是对char*进行了封装
>
> string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。
#### 成员初始化列表的概念，为什么用它会快一些？
> 对于内置类型没什么影响
>
> 如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值(有参构造函数)，而初始化列表只做一次赋值操作(有参构造函数)
#### C++函数调用的压栈过程
> 保存当前函数的执行状态
>
> 压入参数(右->左)
>
> 压入返回地址
>
> 压入esp，调整esp
#### 类的对象存储空间？
> 非静态成员的数据类型大小之和。
>
> 编译器加入的额外成员变量（如指向虚函数表的指针）。
#### 如果在类的析构函数中调用delete this，会发生什么？
> 堆栈溢出，系统崩溃



# STL
#### STL六大组件
> 容器
>
> 算法
>
> 迭代器
>
> 配接器：用来修饰容器或迭代器接口的东西
>
> 仿函数：重载了operator()行为类似函数的函数
>
> 配置器：分配/释放内存
>
> [Link](https://blog.csdn.net/daaikuaichuan/article/details/80717222)
#### array 和 vector 的区别
> array定长数组, vector动态开辟
#### push_back和emplace_back的区别
> push_back添加一个元素先构造，然后拷贝/移动到容器里，然后将原本的删除
> 
> emplace_back添加一个元素直接再容器末尾构造，不需要拷贝/移动
#### push_back和emplace_back的没有区别
> 基础类型
>
> //TODO
#### 主动扩容
> reserve改变容器大小，resize改变存储元素个数
#### resize超过容器大小会发生什么
> 会将容器大小扩展到对应大小
#### map插入有哪几种方式
> insert，emplace，下标
#### insert和emplace的差别
> insert先创建键值对然后拷贝/移动到容器内
>
> emplace直接在容器内创建键值对
>
> 下标插入如果键存在则会直接覆盖不会有任何指示
#### insert
> insert返回pair，第一个元素是所指向的迭代器，第二个元素返回是否成功插入(如果键已经存在则插入失败)
#### 怎么对map进行排序规则的更改
> 写一个仿函数，类里面写bool operate()
#### C++中将临时变量作为返回值时的处理过程
> 临时变量压入栈，返回值放在寄存器里
#### 如何获得结构成员相对于结构开头的字节偏移量
> offsetof宏
#### 指针加减计算要注意什么？
> 移动的步长跟指针的类型是有关系的
#### 怎样判断两个浮点数是否相等？
> 对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值
#### 类如何实现只能静态分配和只能动态分配
> 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建
#### 如果想将某个类用作基类，为什么该类必须定义而非声明？
> 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。
#### 函数调用过程栈的变化，返回值和参数变量哪个先入栈？
> 从右向左依次把被调函数所需要的参数压入栈
>
> 调用者函数使用call指令调用被调函数，调用者函数使用call指令调用被调函数
>
> 保存调用者函数的栈底地址
>
> 存放被调函数中的局部变量和临时变量
#### printf函数的实现原理
> printf的第一个被找到的参数就是那个字符指针
>
> 通过判断字符串里控制参数的个数来判断参数个数及数据类
#### cout和printf有什么区别？
> cout<<是类std::ostream的全局对象
#### strcpy和memcpy的区别
> strcpy只能复制字符串，而memcpy可以复制任意内容
#### 什么情况用指针当参数，什么时候用引用
> 数组，则使用指针
>
> 类对象，则使用const引用
#### 成员初始化列表会在什么时候用到
> 引用
>
> 指针
>
> 基类
>
> 成员类
#### 如何禁止程序自动生成拷贝构造函数
> 定一个base类，base类中将拷贝构造函数和拷贝赋值函数设置成private
#### memset(this,0,sizeof(*this))会发生什么
> 整个对象的内存全部置为0
>
> 类含有虚函数表，会破坏虚函数表
#### 动态编译与静态编译
> 静态编译：编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去
>
> 动态编译：动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令
#### delete和delete[]区别
> delete只会调用一次析构函数
>
> delete[]每个元素都会调用一次析构函数



# Linux操作系统
#### 互斥锁和自旋锁的区别
> 互斥锁阻塞，自旋锁忙等
#### 阻塞和挂起的区别
> 阻塞：线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才回复运行
> 
> 挂起：机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存
#### 如何实现守护进程
#### 六种进程间通信的效率排名
> 共享内存，管道，消息队列，信号量，信号，socket套接字
#### IO多路复用
> select：需要将fds_set从用户态拷贝到内核，fd越多拷贝的越多。内核需要遍历所有文件描述符。且上限是1024。fds集合不能重用每次都要重置。
>
> poll：在select的基础上改善了上限。
>
> epoll
>> 水平触发(LT)
>> 
>> 边缘触发(ET)
#### malloc
> [Link](https://www.cnblogs.com/ssezhangpeng/p/10808969.html)
#### 无锁队列
> [Link](https://blog.csdn.net/lucky52529/article/details/101162787)
#### 内存分布
> cpp
>> 栈
>>
>> 文件映射区(可用于加载动态库/动态申请内存(大于128k))
>>
>> 堆
>>
>> 全局区(包括 未初始化的全局变量/静态变量(.bss)， 已初始化的全局变量/静态变量(.data))
>>
>> 常量区(虚表)
>> 
>> 代码段(包括 代码和只读变量)
>
> linux/c
> 
>> 栈
>>
>> 文件映射区
>>
>> 堆
>>
>> .Bss
>>
>> .Data
>>
>> 代码段
#### select改文件描述符上限
> 通过宏定义
#### 线程比协程的优点
> 
#### io多路复用底层实现
> 
