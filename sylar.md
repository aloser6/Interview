### 日志模块

日志模块整体没用什么难点，他有五个主要的类，

第一个是LogEvent类，这个类的作用起到对日志具体字段的存储，比如常见日志字段时间，线程号等。

第二个是LogFormatter类，这个类的主要作用是按照给定的格式对日志信息进行组装，具体的实现逻辑是在LogFormatter类里创建一个FormatItem类，类中有一个 **纯虚函数** format，然后根据日志字段创建对应的 **子类** 并实现该 **纯虚函数** ，format实现的功能主要是获取LogEvent里的日志字段，然后输出到指定字节流中去。LogFormatter类实现了一个组装函数，组装的依据是根据FormatItem **ptr** 类型的 **vector** 数组，遍历这个数据并调用format，根据 **多态** 的机制，最后顺利组装出一条格式化后的日志信息。

第三个是LogAppender类，这个类很简单，主要是设置日志的输出地，**派生** 两个类，一个是向标准控制台输出日志，一个是向指定文件输出日志，他们都会去调用LogFormatter类中的组装函数，获取一条格式化日志后进行输出

第四个是Logger类，主要负责将存储一些日志模块的关键信息并对外暴露功能性的接口，比如日志类别debug，infor，error等方法，还有设置输出地，设置日志格式等等，他的构造函数对日志的格式进行初始化，在不设置日志格式的情况下会使用默认日志格式，并对格式进行解析，根据解析后的日志格式组装出FormatItem ptr数组。

第五个是LogEventWrap类，是对LogEvent的封装，主要作用是利用其析构函数实现自动调用Logger类的log函数进行日志输出



### 线程模块

线程模块分为两个部分，

第一个部分是对锁的封装，这一部分首先对常见的锁进行封装如锁Mutex，读写锁RWMutex，自旋锁Spinlock，他们都封装了lock和unlock方法，并且使用 **RAII** 风格进行实现，在构造函数时上锁，析构函数时解锁。这些类都继承Noncopyable的类，这个类删除了拷贝构造和赋值构造，防止锁因被复制而导致错误。这一部分还实现了个名为ScopedLockImpl的 **模板类**，该类起到统一接口的作用，传入的类型则是刚刚封装的锁的类型，和之前一样，也都封装了lock和unlock函数并且符合RAII风格。(互斥量被拷贝了会发生什么，举例，假如有两个线程a和b，有一个锁1和一个被拷贝的锁2，假如一开始还没拷贝锁2，a上了锁1，随后b拷贝锁，这是被拷贝的锁2所持有的信息是线程a的信息，也就是说只有a才能解锁，而如果b线程在此时上锁则会一直阻塞，直到线程a把锁2给解锁)

第二部分是对线程的封装，封装了 **join**，**detach **等方法，其中Thread的构造函数需要传入一个回调函数cb，并存储下来，其中这个回调函数使用 **function** 类型，构造函数调用pthread_create来创建线程，pthread_create会调用run函数而不是cb函数，这样做的目的是为了在真正执行cb函数之前做一些初始化工作，比如获取线程id，设置线程名等，等准备工作完成后run函数再调用cb函数并且主线程退出构造函数。为了防止run函数还没调用cb函数，主线程就已经退出了构造函数并进行下一个线程的创建，这里使用了信号量进行控制，当主线程调用完pthread_create后会阻塞在sem_wait上，当run函数初始化工作结束后则会调用sem_notify使得主线程退出构造函数 (为什么不使用cpp11现成的  由于两个线程所以使用sem来控制  syscall(SYS_gettid)获取线程id)



### 协程模块

协程模块使用ucontext库，封装了一个Fiber类，Fiber类主要存储了协程的上下文，协程栈大小，协程执行的入口函数以及协程运行状态，使用swapcontext函数封装了一些协程切换的成员函数，实现的切换为非对称切换，切换逻辑是主协程切换到子协程，当子协程完成任务或者因阻塞需要切换时只能切换到主协程，这么做的目的是为了防止子协程创建新的子协程而最终导致程序跑飞，为了实现这一点，程序维护了两个thread_local线程局部遍变量，一个存储主协程，而另一个存储正在运行的协程，当需要切换到主协程只需swap到主协程的上下文即可，thread_local也以为着每个线程都有主协程，且线程间协程互不干扰。Fiber还设计了一个reset函数，reset函数的作用是将Fiber进行初始化，当一个协程任务运行完以后不需要析构再重新构造Fiber对象，只需直接reset，达到反复利用提高程序效率的目的



### 协程调度模块

之前的协程模块在创建协程任务后需要用户自己手动调用，这显然是不合理的，所以有了协程调度模块，这个模块主要封装了一个Schedule的类，这个类维护了一个协程任务队列，接受协程任务和函数，如果传入的是函数则会封装成协程后再进入调度队列。Schedule类还封装了三个主要函数，start，run，stop。start函数起到线程池的作用，负责创建线程并让线程执行run函数，run函数则是先创建主协程，也可称为调度协程，所以也可以理解为调度协程在跑run函数，然后调度协程去遍历协程队列，找到属于当前线程的协程任务，取出任务并切换到任务协程去执行，执行结束再切换回来循环找任务，如果没任务了就创建一个idle协程并切换到idle协程，idle协程的主要工作就是判断是否有中止状态，没有就切换回调度协程，有就正常退出，在没有stop前等于是idle协程什么也没做，属于忙等，因为是忙等，所以当新任务来的时候也不需要通知，这一点在后面的IOManager会得到优化。stop函数则是设置中止状态然后中值调度器。一般情况，主线程会担任Schedule协程调度器的职责，其它线程则是调度线程，负责消耗协程任务，很显然，在资源有限的情况下主线程也应当担任调度线程的职责，而为了让主线程也参与协程调度则是协程调度模块真正的难点所在。对于非主线程来说，他们的任务可以总结为调度协程遍历任务队列，有任务就切换到任务协程，执行完回调度协程，调度协程继续找任务，没有任务就循环忙等，这些线程不会主动中止，必须主线程去显示调用stop设置stop状态才能中止他们。所以当主线程参与调度就会遇到问题，为了简化问题我们考虑只有主线程的情况，如果主线程也像其它线程一样，让调度协程也就是主协程跑run函数，那么当没有协程任务时他会陷入循环忙等的状态，自己也不能显示调用stop函数设置stop状态来中止自己。为了解决这个问题，引入了一个新的线程局部变量以应对这种情况，加上前面两个线程局部变量现在总共是三个线程局部变量，分别是主协程，调度协程，任务协程，对于普通线程，主协程和调度协程是同一个，对于主线程，主协程和调度协程是分开的。如果仅仅只是添加一个线程变量也还不足以解决问题，因为当调度协程发现没有可执行任务是，他会先切换到idle协程判断是否设置了stop状态，没有则切回调度协程，而并不能主动切回主协程去执行stop函数设置stop状态，为了解决这个问题，将主线程的调度协程的执行时机放到了stop函数里，并放在stop状态被设置后，这样做主协程start后什么也不做，攒一波协程任务，当主协程显示调用stop后再去切换到调度协程执行run函数，当没有任务时切换到idle协程，这时由于已经提前设置了stop状态，所以会正常退出。关于是否启用主线程参与调度任务，在Schedule构造函数设置了参数来决定是否使用主线程去参与调度任务，默认是开启的。



### IO协程调度模块

之前的协程调度模块在没有任务时是处于忙等，造成cpu资源浪费，这是不合理的。IO协程调度模块主要分为两个部分，一方面是引入IO事件调度的功能，另一方面是对之前的忙等状态的优化。IO协程调度模块主要封装了一个IOManager的类，封装了对epollevent增删改的相关成员函数，内部还有一个FdContext主要封装事件的上下文包括fd，事件类型，事件触发后需要执行的回调函数。IOManager继承自Schedule类，拥有Schedule类的所有功能，并重写了idle和ticker函数，当调度协程没有任务执行时会切换到idle协程执行，当有任务时ticker负责提醒任务的到来。IOManager的构造函数先创建一个pipe，给这个pipe创建EPOLLIN可读事件，做一些epoll的相关初始化工作，最后调用start函数让线程跑起来。idle函数调用epoll_wait，让空闲线程阻塞在epoll_wait上，这里有两个作用，一方面时等待IO事件的到来，一方面是假如有协程任务的到来，ticker则会向之前构造函数创建的管道里写一个字符，打破epoll_wait的阻塞，起到通知的作用。然后遍历事件，从epoll_event的私有指针上找回FdContext上下文，将已经被触发的事件剔除，将需要处理的事件加入到协程调度队列里，然后切换到调度协程继续执行上个模块提到的run函数。这里的epoll使用的是边缘触发模式。这样就使得原本的忙等得到了改善，提高了整体的效率。



### 定时器模块

定时器模块的目的是使用户可以添加定时任务，封装了Timer类和TimerManager类，Timer类里主要有需要执行时的绝对时间和相对时间，还有定时结束后所需执行的回调函数。还封装了一些如取消定时器和重置定时器的成员函数。TimerManager类通过维护一个以Timer为key，Comparator为value的集合set，并且以定时的时间从小到大排序，还封装了一些添加定时器任务，获取下一个定时器任务等成员函数。IOManager会继承Timer定时器类，在epoll_wait之前获取下一个定时器任务的超时时间，把超时时间作为epoll_wait的超时时间，这样就实现当定时时间到了，epoll_wait就会被打断然后将定时器任务取出放入协程任务队列里。在插入一个新的定时器任务时有一个细节需要注意，当新添加的定时器任务比当前epoll_wait上的超时时间还要小则需要调用ticker打断epoll_wait让epoll_wait重新获取一下超时时间

### HOOK模块
